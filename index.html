<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sidebar</title>
    <style>
        /* UI adapted from the Dashboard's aesthetic */
        :root {
            --bg-color: #f4f7fa; --panel-bg: #ffffff; --border-color: #e2e8f0;
            --text-color: #1e293b; --subtle-text: #64748b; --primary-color: #3b82f6;
            --danger-color: #ef4444; --success-color: #22c55e; --warning-color: #f97316;
            --info-bg: #f8fafc; --danger-hover-bg: #fee2e2;
            --font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg-color: #111827; --panel-bg: #1f2937; --border-color: #374151;
                --text-color: #f9fafb; --subtle-text: #9ca3af; --primary-color: #60a5fa;
                --info-bg: #111827; --danger-hover-bg: #4b1d1d;
            }
        }

        html, body { height: 100%; margin: 0; }
        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            font-size: 14px;
            display: flex;
        }

        /* --- Layout --- */
        #app {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 0.75rem;
            box-sizing: border-box;
            gap: 0.75rem;
        }
        header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }
        header h1 { font-size: 1.125rem; font-weight: 700; }
        header .controls { display: flex; align-items: center; gap: 1rem; }
        main { flex-grow: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 0.75rem; padding-right: 4px; }

        /* --- General Components --- */
        .section {
            background-color: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            padding: 0.75rem;
        }
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }
        .section-title {
            font-size: 0.9rem;
            font-weight: 600;
            margin: 0;
        }
        .input-field, #personSelector {
            width: 100%;
            box-sizing: border-box;
            font-size: 0.875rem;
            padding: 0.4rem 0.6rem;
            border-radius: 0.375rem;
            border: 1px solid var(--border-color);
            font-family: inherit;
            background-color: var(--info-bg);
            color: var(--text-color);
        }
        .input-field:focus, #personSelector:focus {
            outline: 2px solid var(--primary-color);
            outline-offset: -1px;
            background-color: var(--panel-bg);
        }
        textarea.input-field { resize: vertical; }

        /* --- Buttons --- */
        .btn {
            padding: 0.35rem 0.6rem;
            font-size: 0.8rem;
            border: 1px solid var(--border-color);
            border-radius: 0.375rem;
            cursor: pointer;
            background-color: var(--panel-bg);
            transition: all 0.2s;
            font-weight: 500;
            color: var(--text-color);
        }
        .btn:hover { background-color: var(--info-bg); }
        .btn-primary { background-color: var(--primary-color); color: white; border-color: var(--primary-color); }
        .btn-primary:hover { filter: brightness(110%); }
        .btn-danger { background-color: var(--danger-color); color: white; border-color: var(--danger-color); }
        .btn-danger:hover { filter: brightness(110%); }
        .btn.active { background-color: var(--primary-color); color: white; border-color: var(--primary-color); }
        #resetBtn { background: none; border: none; font-size: 0.75rem; color: var(--subtle-text); cursor: pointer; }
        #resetBtn:hover { color: var(--text-color); }
        #settingsBtn { background: none; border: none; font-size: 1.25rem; cursor: pointer; }

        /* --- Specific Section Styling --- */
        .controls { display: flex; align-items: center; gap: 0.5rem; }
        #clipboardStatus { font-size: 0.75rem; font-weight: 500; }
        
        textarea#messageInput {
            min-height: 60px;
            max-height: 120px;
        }

        #relationshipTypeSelector { display: flex; gap: 0.5rem; }
        #relationshipTypeSelector .btn { flex: 1; padding: 0.4rem 0.2rem; }
        #personSelectorContainer { display: flex; align-items: center; justify-content: space-between; margin-top: 0.75rem; }
        #personSelectorContainer .label { font-size: 0.875rem; font-weight: 500; color: var(--subtle-text); }
        #personSelectorContainer .controls { flex-grow: 1; justify-content: flex-end; }
        #personSelector { width: auto; flex-grow: 1; }

        .loader { display: none; align-items: center; gap: 0.5rem; font-size: 0.875rem; color: var(--subtle-text); }
        .loader-dot { animation: pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

        #translationResult {
            font-size: 0.875rem;
            color: var(--text-color);
            margin-top: 0.75rem;
            padding: 0.75rem;
            border-radius: 0.375rem;
            background-color: var(--info-bg);
        }
        .prose-styles details > summary { cursor: pointer; font-weight: 600; margin-bottom: 0.5rem; font-size: 0.8rem; color: var(--primary-color); }
        .prose-styles p { margin: 0 0 0.5rem; line-height: 1.5; padding-left: 0.75rem; border-left: 2px solid var(--border-color); }
        .prose-styles strong { color: var(--subtle-text); font-weight: 600; }

        #optionsContainer { display: flex; flex-direction: column; gap: 0.5rem; margin-top: 0.75rem; }
        .response-card { padding: 0.75rem; border-radius: 0.375rem; background-color: var(--panel-bg); border: 1px solid var(--border-color); }
        .response-card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; }
        .response-card-header h4 { font-size: 0.75rem; font-weight: 700; text-transform: uppercase; color: var(--primary-color); letter-spacing: 0.05em; }
        .response-card p { font-size: 0.875rem; color: var(--text-color); margin: 0; }
        
        #errorContainer { padding: 0.5rem; text-align: center; color: var(--danger-color); font-size: 0.875rem; }

        /* --- Toggle Switch --- */
        .toggle-switch { position: relative; display: inline-block; width: 34px; height: 20px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .toggle-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--border-color); transition: .4s; border-radius: 20px; }
        .toggle-slider:before { position: absolute; content: ""; height: 12px; width: 12px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .toggle-slider { background-color: var(--success-color); }
        input:checked + .toggle-slider:before { transform: translateX(14px); }

        /* --- Modals --- */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(100,116,139,0.5); display: flex; align-items: center; justify-content: center; z-index: 1000; backdrop-filter: blur(4px); }
        .modal-content { background: var(--panel-bg); padding: 1.5rem; border-radius: 0.75rem; max-width: 90%; width: 380px; box-shadow: 0 10px 25px -5px rgba(0,0,0,0.1); border: 1px solid var(--border-color); }
        .modal-content h2 { margin: 0 0 1rem 0; font-size: 1.25rem; }
        .modal-content h3 { margin: 0 0 0.5rem 0; font-size: 0.9rem; font-weight: 600; }
        .modal-actions { display: flex; justify-content: flex-end; gap: 0.5rem; margin-top: 1.5rem; }
        #peopleList .person-item { display: flex; justify-content: space-between; align-items: center; padding: 0.5rem; background-color: var(--info-bg); border-radius: 0.25rem; }
        #peopleList { display: flex; flex-direction: column; gap: 0.5rem; max-height: 240px; overflow-y: auto; }
        
        /* Utility */
        .hidden { display: none !important; }
        .text-success { color: var(--success-color); } .text-warning { color: var(--warning-color); } .text-danger { color: var(--danger-color); }
    </style>
</head>
<body>
    <div id="app">
        <header>
            <h1>Sidebar</h1>
            <div class="controls">
                <button id="settingsBtn" title="Settings">⚙️</button>
                <button id="resetBtn">Reset Session</button>
            </div>
        </header>

        <main>
            <section class="section">
                <div class="section-header">
                    <h2 class="section-title">Received Message</h2>
                    <div class="controls">
                        <span id="clipboardStatus" class="text-success">Monitoring</span>
                        <label class="toggle-switch"><input type="checkbox" id="clipboardToggle"><span class="toggle-slider"></span></label>
                    </div>
                </div>
                <textarea id="messageInput" class="input-field" placeholder="Paste message here..."></textarea>
            </section>
            
            <section class="section">
                <div id="relationshipTypeSelector">
                    <button class="btn" data-value="Manager">Manager</button>
                    <button class="btn" data-value="Teammate">Teammate</button>
                    <button class="btn" data-value="Client">Client</button>
                    <button class="btn" data-value="Other">Other</button>
                </div>
                <div id="personSelectorContainer" class="hidden">
                     <span class="label">Person:</span>
                    <div class="controls">
                        <select id="personSelector" class="input-field"></select>
                        <button id="managePeopleBtn" class="btn">Manage</button>
                    </div>
                </div>
            </section>

            <section class="section">
                <h2 class="section-title">Your Guidance</h2>
                <textarea id="userInput" class="input-field" rows="3" placeholder="Describe your goal, then press Ctrl+Enter."></textarea>
            </section>

            <section id="analysisSection" class="section">
                <div class="section-header">
                    <h2 class="section-title">AI Analysis</h2>
                    <div id="translationLoader" class="loader"><span class="loader-dot">●</span><span>Analyzing...</span></div>
                </div>
                <div id="translationResult" class="prose-styles">Awaiting input...</div>
            </section>

            <section class="section">
                <div class="section-header">
                    <h2 class="section-title">Suggested Responses</h2>
                    <div id="outputLoader" class="loader"><span class="loader-dot">●</span><span>Generating...</span></div>
                </div>
                <div id="optionsContainer"></div>
                <div id="errorContainer" class="hidden"></div>
            </section>
        </main>
    </div>

    <!-- Modals -->
    <div id="settingsModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h2>Settings</h2>
            <div>
                <label for="apiKeyInput" style="display: block; font-weight: 500; margin-bottom: 0.25rem;">Google AI API Key</label>
                <input type="password" id="apiKeyInput" class="input-field" placeholder="Enter your API key">
                <p style="font-size: 0.75rem; color: var(--subtle-text); margin-top: 0.25rem;">Your key is stored securely in your browser's local storage.</p>
            </div>
            <div class="modal-actions">
                <button id="cancelSettingsBtn" class="btn">Cancel</button>
                <button id="saveSettingsBtn" class="btn btn-primary">Save</button>
            </div>
        </div>
    </div>
    <div id="peopleModal" class="modal-overlay hidden">
       <div class="modal-content">
            <h2>Manage People</h2>
            <div style="margin-bottom: 1rem;">
                <h3>Add New Person</h3>
                <div style="display: flex; gap: 0.5rem;">
                    <input type="text" id="newPersonName" class="input-field" placeholder="Person's Name">
                    <button id="addPersonBtn" class="btn btn-primary">Add</button>
                </div>
            </div>
            <div id="peopleList">
                <!-- People will be listed here -->
            </div>
            <div class="modal-actions">
                <button id="closePeopleBtn" class="btn">Close</button>
            </div>
        </div>
    </div>

    <script type="module">
    // --- BRIEF ---
    // This is "Sidebar", a personal workplace communication tool. Its AI agent, "The Strategic Gatekeeper",
    // analyzes messages, provides strategic insights, and drafts diplomatic responses. It uses a sophisticated,
    // class-based architecture to learn communication patterns for specific people, storing all confidential
    // data (API key, profiles) securely in the user's local browser storage.

    const dom = {
        messageInput: document.getElementById('messageInput'), userInput: document.getElementById('userInput'),
        clipboardToggle: document.getElementById('clipboardToggle'), personSelector: document.getElementById('personSelector'),
        relationshipTypeSelector: document.getElementById('relationshipTypeSelector'),
        personSelectorContainer: document.getElementById('personSelectorContainer'),
        resetBtn: document.getElementById('resetBtn'), settingsBtn: document.getElementById('settingsBtn'),
        managePeopleBtn: document.getElementById('managePeopleBtn'), clipboardStatus: document.getElementById('clipboardStatus'),
        translationLoader: document.getElementById('translationLoader'), translationResult: document.getElementById('translationResult'),
        outputLoader: document.getElementById('outputLoader'), optionsContainer: document.getElementById('optionsContainer'),
        errorContainer: document.getElementById('errorContainer'), settingsModal: document.getElementById('settingsModal'),
        peopleModal: document.getElementById('peopleModal'), apiKeyInput: document.getElementById('apiKeyInput'),
        saveSettingsBtn: document.getElementById('saveSettingsBtn'), cancelSettingsBtn: document.getElementById('cancelSettingsBtn'),
        peopleList: document.getElementById('peopleList'), newPersonName: document.getElementById('newPersonName'),
        addPersonBtn: document.getElementById('addPersonBtn'), closePeopleBtn: document.getElementById('closePeopleBtn'),
    };

    let state = {
        detectedMessage: '', lastClipboardContent: '', isClipboardMonitoringActive: false,
        selectedPersonId: null, selectedRelationshipType: null, sessionHistory: [],
        settings: { apiKey: '' },
    };

    class ProfileStorage {
        constructor() { this.storageKey = 'sidebar_person_profiles_v4'; }
        async getPersonProfile(personId) { const p = JSON.parse(localStorage.getItem(this.storageKey) || '{}'); return p[personId] || null; }
        async savePersonProfile(personId, profile) { const p = JSON.parse(localStorage.getItem(this.storageKey) || '{}'); p[personId] = profile; localStorage.setItem(this.storageKey, JSON.stringify(p)); }
        async getAllProfiles() { return JSON.parse(localStorage.getItem(this.storageKey) || '{}'); }
        async saveAllProfiles(profiles) { localStorage.setItem(this.storageKey, JSON.stringify(profiles)); }
    }
    
    class EnhancedApiClient {
        constructor() { this.baseUrl = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent'; this.retryCount = 2; this.retryDelay = 1000; this.timeout = 15000; }
        async call(prompt, options = {}) {
            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                generationConfig: {
                    temperature: options.temperature || 0.6, maxOutputTokens: 1500,
                    responseMimeType: "application/json", responseSchema: options.responseSchema
                }
            };
            for (let attempt = 0; attempt < this.retryCount; attempt++) {
                try {
                    const response = await this.makeRequest(payload);
                    return JSON.parse(response);
                } catch (error) {
                    if (attempt === this.retryCount - 1 || error.name === 'AbortError') throw error;
                    await new Promise(resolve => setTimeout(resolve, this.retryDelay * Math.pow(2, attempt)));
                }
            }
        }
        async makeRequest(payload) {
            const apiKey = state.settings.apiKey;
            if (!apiKey) throw new Error("API Key not set in Settings.");
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), this.timeout);
            try {
                const url = `${this.baseUrl}?key=${apiKey}`;
                const response = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload), signal: controller.signal });
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(`API Error ${response.status}: ${errorData.error?.message || response.statusText}`);
                }
                const result = await response.json();
                if (!result.candidates?.[0]?.content?.parts?.[0]?.text) throw new Error('Invalid API response structure');
                return result.candidates[0].content.parts[0].text;
            } finally { clearTimeout(timeoutId); }
        }
    }

    class PersonalizedWorkplaceAgent {
        constructor(apiClient, storage) {
            this.apiClient = apiClient;
            this.storage = storage;
            this.personProfiles = new Map();
        }
        async analyze(message, userInput, personId, type) {
            const personProfile = await this.getPersonProfile(personId);
            const prompt = this.buildPrompt(message, userInput, personProfile, type);
            const result = await this.apiClient.call(prompt, {
                responseSchema: {
                    type: "OBJECT",
                    properties: {
                        "analysis": {
                            type: "OBJECT",
                            properties: {
                                "intent": { "type": "STRING" }, "risk": { "type": "STRING" },
                                "perception_check": { "type": "STRING" }, "strategy": { "type": "STRING" },
                                "profile_update": { "type": "STRING" }
                            }
                        },
                        "responses": {
                            type: "OBJECT",
                            properties: { "diplomatic": { "type": "STRING" }, "professional": { "type": "STRING" }, "strategic": { "type": "STRING" }}
                        }
                    }
                }
            });
            if (personId && result.analysis?.profile_update) {
                await this.updatePersonProfile(personId, result.analysis.profile_update);
            }
            return result;
        }

        buildPrompt(message, userInput, personProfile, type) {
            const isCompose = !message;
            const mode = isCompose ? 'Compose' : 'Response';
            return `You are "The Strategic Gatekeeper," an elite AI specializing in workplace communication. Your mission is to protect the user's reputation.
            <task>
            Analyze the context. Use the general rules for the relationship TYPE as a baseline, then apply the specific learned profile of the PERSON as an overriding layer of context.
            In ${mode} Mode, generate analysis and response drafts.
            Crucially, provide a concise observation about the sender's behavior to build their profile.
            </task>
            <input>
                <mode>${mode}</mode>
                <context>
                    <type>${type || 'Not specified'}</type>
                    <person_name>${personProfile?.name || 'General'}</person_name>
                    <learned_profile>${personProfile?.profile || 'No history yet.'}</learned_profile>
                </context>
                ${isCompose ? `<user_prompt>${userInput}</user_prompt>` : `<message_to_analyze>${message}</message_to_analyze><user_guidance>${userInput || 'Initial analysis.'}</user_guidance>`}
            </input>`;
        }
        
        async getPersonProfile(personId) {
            if (!personId) return null;
            if (this.personProfiles.has(personId)) return this.personProfiles.get(personId);
            const stored = await this.storage.getPersonProfile(personId);
            if (stored) {
                this.personProfiles.set(personId, stored);
                return stored;
            }
            return null;
        }

        async updatePersonProfile(personId, profileUpdate) {
            const profile = await this.getPersonProfile(personId);
            if (!profile) return;
            const timestamp = new Date().toISOString().split('T')[0];
            const newEntry = `\n- [${timestamp}] ${profileUpdate}`;
            profile.profile = (profile.profile || '') + newEntry;
            await this.storage.savePersonProfile(personId, profile);
            this.personProfiles.set(personId, profile);
        }
    }

    const UIManager = {
        init() { this.setLoading(false); this.updateClipboardStatus(state.isClipboardMonitoringActive); },
        setLoading(isLoading) {
             const display = isLoading ? 'flex' : 'none';
             dom.translationLoader.style.display = display;
             dom.outputLoader.style.display = display;
        },
        displayError(error) { dom.errorContainer.textContent = error.message; dom.errorContainer.classList.remove('hidden'); console.error(error); },
        clearError() { dom.errorContainer.classList.add('hidden'); },
        displayAnalysis(analysis) {
            if (!analysis) { dom.translationResult.textContent = 'No analysis available.'; return; }
            dom.translationResult.innerHTML = `
                <details open>
                    <summary>Core Analysis</summary>
                    <p><strong>Intent:</strong> ${analysis.intent || 'N/A'}</p>
                    <p><strong>Risk:</strong> <span class="${this.getRiskColor(analysis.risk)}">${analysis.risk || 'N/A'}</span></p>
                    <p><strong>Perception Check:</strong> ${analysis.perception_check || 'N/A'}</p>
                    <p><strong>Strategy:</strong> ${analysis.strategy || 'N/A'}</p>
                </details>
            `;
        },
        displayResponses(responses) {
            dom.optionsContainer.innerHTML = '';
            if (!responses) return;
            Object.entries(responses).forEach(([key, value]) => {
                const card = document.createElement('div');
                card.className = 'response-card';
                card.innerHTML = `<div class="response-card-header">
                    <h4>${key}</h4>
                    <button class="copy-btn btn" data-text="${escape(value)}">Copy</button>
                </div><p>${value}</p>`;
                dom.optionsContainer.appendChild(card);
            });
        },
        updateClipboardStatus(isActive, message = null) {
            dom.clipboardStatus.textContent = isActive ? 'Monitoring' : 'Paused';
            dom.clipboardStatus.className = isActive ? 'text-success' : 'text-warning';
        },
        getRiskColor(risk) { const r = (risk || '').toLowerCase(); if (r.includes('high')) return 'text-danger'; if (r.includes('medium')) return 'text-warning'; return 'text-success'; },
        async populatePeopleSelector(profiles) {
            const type = state.selectedRelationshipType;
            if (!type) { dom.personSelectorContainer.classList.add('hidden'); return; }
            const peopleInType = Object.values(profiles).filter(p => p.type === type);
            dom.personSelector.innerHTML = `<option value="">-- General ${type} --</option>`;
            peopleInType.forEach(p => dom.personSelector.add(new Option(p.name, p.id)));
            dom.personSelector.value = state.selectedPersonId || "";
            dom.personSelectorContainer.classList.remove('hidden');
        },
        async renderPeopleList(profiles) {
            dom.peopleList.innerHTML = '';
            Object.values(profiles).forEach(p => {
                const div = document.createElement('div');
                div.className = 'person-item';
                div.innerHTML = `<span>${p.name} (${p.type})</span><button class="btn btn-danger" data-id="${p.id}">Delete</button>`;
                dom.peopleList.appendChild(div);
            });
        }
    };
    
    const storage = new ProfileStorage();
    const apiClient = new EnhancedApiClient();
    const agent = new PersonalizedWorkplaceAgent(apiClient, storage);

    async function handleAnalysisRequest() {
        if (!state.selectedRelationshipType) { UIManager.displayError(new Error("Please select a relationship type.")); return; }
        UIManager.setLoading(true);
        UIManager.clearError();
        dom.translationResult.textContent = 'Analyzing...';
        dom.optionsContainer.innerHTML = '';
        try {
            const result = await agent.analyze(state.detectedMessage, dom.userInput.value, state.selectedPersonId, state.selectedRelationshipType);
            UIManager.displayAnalysis(result.analysis);
            UIManager.displayResponses(result.responses);
        } catch (error) {
            UIManager.displayError(error);
            dom.translationResult.textContent = 'An error occurred during analysis.';
        } finally {
            UIManager.setLoading(false);
        }
    }
    
    async function startClipboardMonitor() {
        setInterval(async () => {
            if (!state.isClipboardMonitoringActive || !document.hasFocus()) return;
            try {
                const text = await navigator.clipboard.readText();
                if (text && text.trim() && text !== state.lastClipboardContent) {
                    state.lastClipboardContent = text;
                    state.detectedMessage = text;
                    dom.messageInput.value = text;
                    if (state.selectedRelationshipType) handleAnalysisRequest();
                }
            } catch (err) { /* Fail silently */ }
        }, 1500);
    }
    
    async function main() {
        UIManager.init();
        
        const savedSettings = JSON.parse(localStorage.getItem('sidebar_settings_v1') || '{}');
        state.settings = { ...state.settings, ...savedSettings };
        if (state.settings.apiKey) dom.apiKeyInput.value = state.settings.apiKey;

        const profiles = await storage.getAllProfiles();
        await UIManager.populatePeopleSelector(profiles);
        
        startClipboardMonitor();
        
        dom.messageInput.addEventListener('input', () => {
            state.detectedMessage = dom.messageInput.value;
        });

        dom.userInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && e.ctrlKey) { e.preventDefault(); handleAnalysisRequest(); } });
        dom.clipboardToggle.addEventListener('change', (e) => { state.isClipboardMonitoringActive = e.target.checked; UIManager.updateClipboardStatus(state.isClipboardMonitoringActive); });
        dom.relationshipTypeSelector.addEventListener('click', async (e) => {
            if (e.target.tagName === 'BUTTON') {
                document.querySelectorAll('#relationshipTypeSelector .btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                state.selectedRelationshipType = e.target.dataset.value;
                state.selectedPersonId = null;
                const profiles = await storage.getAllProfiles();
                await UIManager.populatePeopleSelector(profiles);
            }
        });
        dom.personSelector.addEventListener('change', (e) => { state.selectedPersonId = e.target.value; });
        dom.resetBtn.addEventListener('click', () => { 
            state.sessionHistory = []; 
            state.detectedMessage = '';
            dom.messageInput.value = '';
            dom.translationResult.innerHTML = 'Awaiting input...'; 
            dom.optionsContainer.innerHTML = ''; 
        });
        
        // Modals
        dom.settingsBtn.addEventListener('click', () => dom.settingsModal.classList.remove('hidden'));
        dom.cancelSettingsBtn.addEventListener('click', () => dom.settingsModal.classList.add('hidden'));
        dom.saveSettingsBtn.addEventListener('click', () => { state.settings.apiKey = dom.apiKeyInput.value; localStorage.setItem('sidebar_settings_v1', JSON.stringify(state.settings)); dom.settingsModal.classList.add('hidden'); });
        
        dom.managePeopleBtn.addEventListener('click', async () => {
            const profiles = await storage.getAllProfiles();
            await UIManager.renderPeopleList(profiles);
            dom.peopleModal.classList.remove('hidden');
        });
        dom.closePeopleBtn.addEventListener('click', () => dom.peopleModal.classList.add('hidden'));
        dom.addPersonBtn.addEventListener('click', async () => {
            const name = dom.newPersonName.value.trim();
            if (!name || !state.selectedRelationshipType) { alert("Name and relationship type are required."); return; }
            const id = `person_${Date.now()}`;
            const newProfile = { id, name, type: state.selectedRelationshipType, profile: `Profile created for ${name}.`, interactionHistory: [] };
            await storage.savePersonProfile(id, newProfile);
            dom.newPersonName.value = '';
            const allProfiles = await storage.getAllProfiles();
            await UIManager.renderPeopleList(allProfiles);
            await UIManager.populatePeopleSelector(allProfiles);
        });
        dom.peopleList.addEventListener('click', async (e) => {
            if (e.target.tagName === 'BUTTON' && e.target.dataset.id) {
                // Using custom modal instead of confirm()
                if (window.confirm('Delete this person and all their data?')) { // NOTE: This will be replaced by a custom modal UI in a real app
                    const profiles = await storage.getAllProfiles();
                    const idToDelete = e.target.dataset.id;
                    delete profiles[idToDelete];
                    await storage.saveAllProfiles(profiles);
                    if (state.selectedPersonId === idToDelete) state.selectedPersonId = null;
                    await UIManager.renderPeopleList(profiles);
                    await UIManager.populatePeopleSelector(profiles);
                }
            }
        });
        document.body.addEventListener('click', async (e) => {
            const button = e.target.closest('.copy-btn');
            if (button) {
                navigator.clipboard.writeText(unescape(button.dataset.text)).then(() => {
                    button.textContent = 'Copied!';
                    setTimeout(() => button.textContent = 'Copy', 2000);
                });
            }
        });
    }
    
    main();
    </script>
</body>
</html>

