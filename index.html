<!DOCTYPE html>
<!-- LLM-NOTE: This application is optimized exclusively for Microsoft Edge. Do not add cross-browser compatibility code. -->
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sidebar</title>
    <style>
        /* LLM-NOTE: All styling is self-contained. Do not introduce external CSS frameworks. */
        :root {
            --bg-color: #f4f7fa; --panel-bg: #ffffff; --border-color: #e2e8f0;
            --text-color: #1e293b; --subtle-text: #64748b; --primary-color: #3b82f6;
            --danger-color: #ef4444; --success-color: #22c55e; --warning-color: #f97316;
            --info-bg: #f8fafc; --danger-hover-bg: #fee2e2;
            --font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg-color: #111827; --panel-bg: #1f2937; --border-color: #374151;
                --text-color: #f9fafb; --subtle-text: #9ca3af; --primary-color: #60a5fa;
                --info-bg: #111827; --danger-hover-bg: #4b1d1d;
            }
        }

        html, body { height: 100%; margin: 0; }
        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            font-size: 14px;
            display: flex;
            overflow: hidden; /* Prevent body scroll with toasts */
        }

        /* --- Layout & Core Components --- */
        #app { width: 100%; height: 100vh; display: flex; flex-direction: column; padding: 0.75rem; box-sizing: border-box; gap: 0.5rem; }
        main { flex-grow: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 0.5rem; padding-right: 4px; }
        footer { padding: 0.5rem 0; display: flex; justify-content: flex-end; gap: 0.5rem; flex-shrink: 0; }
        .section { background-color: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 0.5rem; padding: 0.5rem; }
        .section-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.4rem; }
        .section-title { font-size: 0.9rem; font-weight: 600; margin: 0; white-space: nowrap; }
        .input-field, select { width: 100%; box-sizing: border-box; font-size: 0.875rem; padding: 0.4rem 0.6rem; border-radius: 0.375rem; border: 1px solid var(--border-color); font-family: inherit; background-color: var(--info-bg); color: var(--text-color); }
        .input-field:focus, select:focus { outline: 2px solid var(--primary-color); outline-offset: -1px; background-color: var(--panel-bg); }
        textarea.input-field { resize: vertical; }

        /* --- Buttons & Controls --- */
        .btn { padding: 0.35rem 0.6rem; font-size: 0.8rem; border: 1px solid var(--border-color); border-radius: 0.375rem; cursor: pointer; background-color: var(--panel-bg); transition: background-color 0.2s; font-weight: 500; color: var(--text-color); }
        .section-header .controls .btn, .section-header .controls select { padding-top: 0.2rem; padding-bottom: 0.2rem; font-size: 0.75rem; }
        .btn:hover { background-color: var(--info-bg); }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; }
        .btn-primary { background-color: var(--primary-color); color: white; border-color: var(--primary-color); }
        .btn-primary:hover { filter: brightness(110%); }
        .btn-danger { background-color: var(--danger-color); color: white; border-color: var(--danger-color); }
        .btn-danger:hover { filter: brightness(110%); }
        #clearInputsBtn, #settingsBtn { background: none; border: none; font-size: 1.1rem; color: var(--subtle-text); cursor: pointer; padding: 0.2rem; }
        #clearInputsBtn:hover, #settingsBtn:hover { color: var(--text-color); }
        
        /* --- Specific UI Sections --- */
        .controls { display: flex; align-items: center; gap: 0.5rem; }
        .section-header .controls { flex-grow: 1; justify-content: flex-end; flex-wrap: nowrap; min-width: 0; }
        textarea#messageInput { min-height: 60px; max-height: 120px; }
        #recipientSelectorContainer { display: flex; flex-grow: 1; gap: 0.5rem; align-items: center; min-width: 100px; }
        #recipientSelector { max-width: 120px; text-overflow: ellipsis; white-space: nowrap; overflow: hidden; }
        #personaSelector { max-width: 120px; }
        .loader { display: none; align-items: center; gap: 0.5rem; font-size: 0.875rem; color: var(--subtle-text); }
        .loader-dot { animation: pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .input-group { display: flex; gap: 0.5rem; margin-top: 0.5rem; }

        /* --- Analysis & Response Display --- */
        #analysisSection { transition: all 0.3s ease-in-out; }
        #translationResult { font-size: 0.875rem; color: var(--text-color); padding: 0.75rem; border-radius: 0.375rem; background-color: var(--info-bg); }
        #apiKeyCta { text-align: center; padding: 1rem; background-color: var(--info-bg); border-radius: .5rem; }
        #apiKeyCta p { margin: 0 0 0.75rem 0; color: var(--text-color); }
        .prose-styles p { margin: 0 0 0.75rem; line-height: 1.5; color: var(--text-color); }
        .prose-styles strong { color: var(--subtle-text); font-weight: 600; }
        .empty-state-text { color: var(--subtle-text); text-align: center; padding: 1rem; }
        #optionsContainer { display: flex; flex-direction: column; gap: 0.5rem; margin-top: 0.75rem; }
        .response-card { padding: 0.75rem; border-radius: 0.375rem; background-color: var(--panel-bg); border: 1px solid var(--border-color); border-left: 4px solid transparent; transition: border-color 0.2s; }
        .response-card.primary { border-left: 4px solid var(--primary-color); background: linear-gradient(90deg, color-mix(in srgb, var(--primary-color) 5%, transparent) 0%, transparent 100%);}
        .response-card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; }
        .response-card-header h4 { font-size: 0.8rem; font-weight: 700; color: var(--primary-color); }
        .response-card p { font-size: 0.875rem; color: var(--text-color); margin: 0; white-space: pre-wrap; white-space: pre-line; word-break: break-word; overflow-wrap: break-word; hyphens: auto; }

        /* --- Modals & Overlays --- */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(100,116,139,0.5); display: flex; align-items: center; justify-content: center; z-index: 1000; backdrop-filter: blur(4px); }
        .modal-content { background: var(--panel-bg); padding: 1.5rem; border-radius: 0.75rem; max-width: min(95vw, 420px); width: 420px; box-shadow: 0 10px 25px -5px rgba(0,0,0,0.1); border: 1px solid var(--border-color); display: flex; flex-direction: column; max-height: min(90vh, 600px); overflow-y: auto; }
        .modal-content h2 { margin: 0 0 1rem 0; font-size: 1.25rem; }
        .modal-content h3 { margin: 0 0 0.5rem 0; font-size: 0.9rem; font-weight: 600; }
        .modal-actions { display: flex; justify-content: flex-end; gap: 0.5rem; margin-top: 1.5rem; flex-shrink: 0; }
        #peopleList .person-item { display: flex; flex-direction: column; padding: 0.5rem; background-color: var(--info-bg); border-radius: 0.25rem; }
        .person-item-header { display: flex; justify-content: space-between; align-items: center; }
        #peopleList .person-controls { display: flex; gap: 0.5rem; }
        #peopleList { display: flex; flex-direction: column; gap: 0.5rem; max-height: 240px; overflow-y: auto; }
        .form-group { margin-bottom: 1rem; }
        .form-group label, .form-group p, .help-link { display: block; margin-bottom: 0.25rem; font-size: 0.875rem; }
        .form-group p { font-size: 0.75rem; color: var(--subtle-text); margin-top: 0.25rem; }
        .help-link { color: var(--primary-color); text-decoration: none; margin-top: 0.5rem; }
        .profile-details { margin-top: 0.75rem; border-top: 1px solid var(--border-color); padding-top: 0.75rem; }
        .profile-details h4 { font-size: 0.8rem; font-weight: 600; margin: 0 0 0.5rem 0; }
        .summary-warning { font-size: 0.75rem; color: var(--warning-color); margin-bottom: 0.5rem; }
        .summary-char-count { font-size: 0.75rem; color: var(--subtle-text); text-align: right; }
        .form-group .error-message { font-size: 0.75rem; color: var(--danger-color); margin-top: 0.25rem; }
        
        /* --- Toast Notifications --- */
        .toast { position: fixed; bottom: -100px; left: 50%; transform: translateX(-50%); padding: 0.75rem 1.25rem; border-radius: 0.5rem; box-shadow: 0 4px 10px rgba(0,0,0,0.1); font-size: 0.875rem; z-index: 2000; transition: bottom 0.5s cubic-bezier(0.25, 1, 0.5, 1); color: white; }
        .toast.show { bottom: 20px; }
        .toast-error { background-color: var(--danger-color); }
        .toast-success { background-color: var(--success-color); }
        .toast-info { background-color: var(--primary-color); }

        #onboardingOverlay { position: fixed; inset: 0; background: var(--bg-color); z-index: 2000; padding: 2rem; color: var(--text-color); }
        #onboardingContent { max-width: 600px; margin: auto; }
        #onboardingContent h1 { font-size: 1.5rem; margin-bottom: 1rem; }
        #onboardingContent p, #onboardingContent li { line-height: 1.6; margin-bottom: 1rem; }
        #onboardingContent ol { padding-left: 1.5rem; }
        #onboardingContent kbd { background: var(--border-color); padding: 0.1rem 0.4rem; border-radius: 0.25rem; font-family: monospace; }
        
        .hidden { display: none !important; }

        .text-success { color: var(--success-color); }
        .text-warning { color: var(--warning-color); }
        .text-danger { color: var(--danger-color); }

        @media (max-width: 400px) {
            .modal-content {
                margin: 1rem;
                padding: 1rem;
            }
        }
        @media (max-width: 320px) {
            .section-header {
                flex-direction: column;
                align-items: stretch;
                gap: 0.5rem;
            }
            .controls {
                justify-content: space-between;
            }
        }
    </style>
</head>
<body>
    <div id="onboardingOverlay" class="hidden">
        <div id="onboardingContent">
            <h1>Welcome to Sidebar</h1>
            <p>This application is designed to run in the Microsoft Edge sidebar for the best experience.</p>
            <h3>Recommended Setup:</h3>
            <ol>
                <li><strong>Enable the Sidebar:</strong> In Edge, go to Settings (`...`) > `Sidebar`, or press <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>/</kbd>.</li>
                <li><strong>Add This App:</strong> In the sidebar, click the `+` icon, find this app under "Open tabs," and pin it.</li>
                <li><strong>Set Your API Key:</strong> To activate the AI, you need a Google AI API key. You can add this in the app's settings (‚öôÔ∏è). <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener" class="help-link">Get your key here.</a></li>
                <li><strong>Keyboard Shortcut:</strong> Press <kbd>Ctrl</kbd> + <kbd>Enter</kbd> in the context box to trigger analysis.</li>
            </ol>
            <button id="dismissOnboardingBtn" class="btn btn-primary" style="margin-top: 1rem;">Continue to App</button>
        </div>
    </div>

    <div id="app" class="hidden">
        <main>
            <section class="section">
                <div class="section-header">
                    <h2 class="section-title">Received Message</h2>
                     <div class="controls">
                        <div id="recipientSelectorContainer" class="hidden">
                            <select id="recipientSelector"></select>
                        </div>
                    </div>
                </div>
                <textarea id="messageInput" class="input-field" placeholder="Paste a message here to get started..."></textarea>
                 <button id="analyzeBtn" class="btn btn-primary" style="width: 100%; margin-top: 0.5rem;" disabled>Analyze</button>
            </section>
            
            <section class="section">
                <div class="section-header">
                    <h2 id="userInputTitle" class="section-title">Add Context</h2>
                    <div id="contextControls" class="controls">
                         <button id="endConversationBtn" class="btn hidden" title="Summarizes this conversation and adds it to the person's long-term profile.">Save Session</button>
                    </div>
                </div>
                <textarea id="userInput" class="input-field" rows="2" placeholder="What is your goal? (e.g., 'decline this politely')"></textarea>
            </section>

            <section id="analysisSection" class="section hidden">
                <div class="section-header">
                    <h2 id="analysisTitle" class="section-title">AI Analysis</h2>
                    <div id="translationLoader" class="loader"><span class="loader-dot">‚óè</span><span>Analyzing...</span></div>
                </div>
                <div id="translationResult" class="prose-styles"></div>
                <div id="apiKeyCta" class="hidden">
                    <p>Please set your API key to enable AI features.</p>
                    <button id="ctaSettingsBtn" class="btn btn-primary">Open Settings</button>
                </div>
            </section>

            <section id="responsesSection" class="section hidden">
                <div class="section-header">
                    <h2 class="section-title">Suggested Responses</h2>
                    <div class="controls">
                        <select id="personaSelector" title="Choose a persona to change the communication style.">
                            <option value="diplomat" selected title="Prioritizes harmony and de-escalates tension.">Diplomat</option>
                            <option value="challenger" title="Sets clear boundaries and respectfully pushes back.">Challenger</option>
                            <option value="coach" title="Empowers and guides through questioning and support.">Coach</option>
                            <option value="visionary" title="Inspires action by focusing on long-term goals.">Visionary</option>
                            <option value="pragmatist" title="Data-driven, direct, and focused on practical solutions.">Pragmatist</option>
                        </select>
                        <div id="outputLoader" class="loader"><span class="loader-dot">‚óè</span><span>Generating...</span></div>
                    </div>
                </div>
                <div id="optionsContainer"></div>
            </section>
        </main>
        <footer>
            <button id="clearInputsBtn" title="Clear All Inputs" aria-label="Clear all inputs">üóëÔ∏è</button>
            <button id="settingsBtn" title="Settings" aria-label="Open settings">‚öôÔ∏è</button>
        </footer>
    </div>

    <!-- Modals -->
    <div id="settingsModal" class="modal-overlay hidden" role="dialog" aria-modal="true">
       <div class="modal-content">
            <h2>Settings</h2>
            <div class="form-group">
                <label for="geminiApiKeyInput">Google AI API Key</label>
                <input type="password" id="geminiApiKeyInput" class="input-field" placeholder="Enter your API key">
                <p>Your key is stored in this browser's local storage. Do not use this on a shared computer.</p>
                <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener" class="help-link">How to get a Google AI API key?</a>
            </div>
             <div class="form-group" style="border-top: 1px solid var(--border-color); padding-top: 1rem;">
                <label>Data Management</label>
                <button id="managePeopleSettingsBtn" class="btn">Manage People</button>
                <button id="clearDataBtn" class="btn btn-danger">Clear All Local Data</button>
                <p>This will permanently delete all saved profiles and session history from this browser.</p>
             </div>
            <div class="modal-actions">
                <button id="cancelSettingsBtn" class="btn">Cancel</button>
                <button id="saveSettingsBtn" class="btn btn-primary">Save</button>
            </div>
        </div>
    </div>
    <div id="peopleModal" class="modal-overlay hidden" role="dialog" aria-modal="true">
       <div class="modal-content">
            <h2>Manage People</h2>
            <div class="form-group">
                <h3>Add New Person</h3>
                <input type="text" id="newPersonName" class="input-field" placeholder="Person's Name" style="margin-bottom: 0.5rem;">
                <select id="newPersonRelationshipType" class="input-field" style="margin-bottom: 0.5rem;"></select>
                <div id="customRoleGroup" class="form-group hidden">
                    <input type="text" id="newPersonRole" class="input-field" placeholder="Specify Relationship (e.g., Contractor)">
                </div>
                <button id="addPersonBtn" class="btn btn-primary">Add</button>
            </div>
            <div id="peopleList"></div>
            <div class="modal-actions">
                <button id="closePeopleBtn" class="btn">Close</button>
            </div>
        </div>
    </div>
     <div id="confirmModal" class="modal-overlay hidden" role="dialog" aria-modal="true">
       <div class="modal-content">
            <h2 id="confirmTitle">Confirm Action</h2>
            <p id="confirmMessage" style="line-height: 1.5;"></p>
            <div class="modal-actions">
                <button id="confirmCancelBtn" class="btn">Cancel</button>
                <button id="confirmOkBtn" class="btn btn-danger">OK</button>
            </div>
        </div>
    </div>
    
    <script type="module">
    'use strict';

    const CONFIG = {
        SESSION_TIME_WINDOW_MS: 10 * 60 * 1000,
        STORAGE_KEYS: { 
            PROFILES: 'sidebar_person_profiles_v11', 
            SESSIONS: 'sidebar_conversation_sessions_v5', 
            SETTINGS: 'sidebar_settings_v6' 
        },
        OLD_STORAGE_KEYS: {
            PROFILES: ['sidebar_person_profiles_v10', 'sidebar_person_profiles_v9'],
            SESSIONS: ['sidebar_conversation_sessions_v4', 'sidebar_conversation_sessions_v3'],
            SETTINGS: ['sidebar_settings_v5']
        },
        API_RETRY_COUNT: 2, API_TIMEOUT_MS: 15000,
        SIDEBAR_MAX_WIDTH: 400,
        PROFILE_SUMMARY_WARNING_LENGTH: 1500,
        STANDARD_RELATIONSHIPS: ["Manager", "Teammate", "Client", "Direct Report", "Stakeholder", "Vendor"],
        PROFILE_CACHE_MAX_SIZE: 20,
        API_CACHE_MAX_SIZE: 20,
        DEBOUNCE_MS_FAST: 800,
    };
    
    const PERSONA_CONFIGS = {
        diplomat: { traits: "prioritizes harmony, uses collaborative language, seeks win-win solutions", tone: "warm, inclusive, diplomatic" },
        challenger: { traits: "sets clear boundaries, asks direct questions, pushes back respectfully", tone: "direct, confident, assertive" },
        coach: { traits: "empowers and guides through questioning and support", tone: "supportive, inquisitive, guiding" },
        visionary: { traits: "inspires action by focusing on long-term goals and possibilities", tone: "inspirational, forward-looking, passionate" },
        pragmatist: { traits: "is data-driven, direct, and focused on practical, efficient solutions", tone: "analytical, straightforward, objective" }
    };

    const dom = {
        app: document.getElementById('app'), onboardingOverlay: document.getElementById('onboardingOverlay'), dismissOnboardingBtn: document.getElementById('dismissOnboardingBtn'),
        messageInput: document.getElementById('messageInput'), userInput: document.getElementById('userInput'),
        userInputTitle: document.getElementById('userInputTitle'),
        recipientSelector: document.getElementById('recipientSelector'),
        personaSelector: document.getElementById('personaSelector'),
        recipientSelectorContainer: document.getElementById('recipientSelectorContainer'),
        clearInputsBtn: document.getElementById('clearInputsBtn'), settingsBtn: document.getElementById('settingsBtn'),
        translationLoader: document.getElementById('translationLoader'), translationResult: document.getElementById('translationResult'),
        analysisTitle: document.getElementById('analysisTitle'),
        analyzeBtn: document.getElementById('analyzeBtn'),
        apiKeyCta: document.getElementById('apiKeyCta'), ctaSettingsBtn: document.getElementById('ctaSettingsBtn'),
        outputLoader: document.getElementById('outputLoader'), optionsContainer: document.getElementById('optionsContainer'),
        contextControls: document.getElementById('contextControls'), endConversationBtn: document.getElementById('endConversationBtn'),
        settingsModal: document.getElementById('settingsModal'), geminiApiKeyInput: document.getElementById('geminiApiKeyInput'),
        clearDataBtn: document.getElementById('clearDataBtn'),
        managePeopleSettingsBtn: document.getElementById('managePeopleSettingsBtn'),
        saveSettingsBtn: document.getElementById('saveSettingsBtn'), cancelSettingsBtn: document.getElementById('cancelSettingsBtn'), 
        peopleModal: document.getElementById('peopleModal'), peopleList: document.getElementById('peopleList'), 
        newPersonName: document.getElementById('newPersonName'), addPersonBtn: document.getElementById('addPersonBtn'), 
        newPersonRelationshipType: document.getElementById('newPersonRelationshipType'),
        customRoleGroup: document.getElementById('customRoleGroup'), newPersonRole: document.getElementById('newPersonRole'),
        closePeopleBtn: document.getElementById('closePeopleBtn'),
        analysisSection: document.getElementById('analysisSection'),
        responsesSection: document.getElementById('responsesSection'),
        confirmModal: document.getElementById('confirmModal'), confirmTitle: document.getElementById('confirmTitle'), confirmMessage: document.getElementById('confirmMessage'),
        confirmCancelBtn: document.getElementById('confirmCancelBtn'), confirmOkBtn: document.getElementById('confirmOkBtn'),
    };

    let state = {
        detectedMessage: '', lastClipboardContent: '',
        selectedPersonId: null, selectedPersona: 'diplomat',
        settings: { apiKey: null, onboardingDismissed: false },
        lastAnalysis: null,
    };

    let activeModal = null;
    let focusedElementBeforeModal = null;
    let operationInProgress = false;
    let renderQueued = false;
    let pendingPersonSwitch = null;
    
    const debounce = (fn, delay) => {
        let t;
        const debounced = (...args) => {
            clearTimeout(t);
            t = setTimeout(() => fn(...args), delay);
        };
        debounced.cancel = () => {
            clearTimeout(t);
        };
        return debounced;
    };

    function decodeHtmlEntities(text) {
        if (!text) return '';
        const ta = document.createElement('textarea');
        ta.innerHTML = text;
        return ta.value;
    }

    function showToast(message, type = 'info', duration = 4000) {
        const toast = document.createElement('div');
        toast.className = `toast toast-${type}`;
        toast.textContent = message;
        document.body.appendChild(toast);
        setTimeout(() => toast.classList.add('show'), 100);
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => document.body.removeChild(toast), 500);
        }, duration);
    }

    function showConfirmationModal(title, message) {
        return new Promise((resolve) => {
            dom.confirmTitle.textContent = title;
            dom.confirmMessage.textContent = message;
            UIManager.openModal(dom.confirmModal);
            const handleConfirm = () => { cleanup(); resolve(true); };
            const handleCancel = () => { cleanup(); resolve(false); };
            const cleanup = () => {
                dom.confirmOkBtn.removeEventListener('click', handleConfirm);
                dom.confirmCancelBtn.removeEventListener('click', handleCancel);
                UIManager.closeModal(dom.confirmModal);
            };
            dom.confirmOkBtn.addEventListener('click', handleConfirm, { once: true });
            dom.confirmCancelBtn.addEventListener('click', handleCancel, { once: true });
        });
    }

    function validateAIResponse(response) {
      if (!response || typeof response !== 'object') return false;
      if (!response.analysis || typeof response.analysis !== 'object') return false;
      if (!Array.isArray(response.responses)) return false;
      const requiredAnalysisFields = ['insight', 'strategy', 'risk'];
      if (!requiredAnalysisFields.every(field => typeof response.analysis[field] === 'string')) return false;
      return response.responses.every(r => r && typeof r.title === 'string' && typeof r.text === 'string' && r.title.length > 0 && r.text.length > 0);
    }
    
    class LRUCache {
        constructor(maxSize = 50) { this.maxSize = maxSize; this.cache = new Map(); }
        get(key) { if (this.cache.has(key)) { const value = this.cache.get(key); this.cache.delete(key); this.cache.set(key, value); return value; } return null; }
        set(key, value) { if (this.cache.has(key)) { this.cache.delete(key); } else if (this.cache.size >= this.maxSize) { const firstKey = this.cache.keys().next().value; this.cache.delete(firstKey); } this.cache.set(key, value); }
    }

    class SessionManager {
        constructor() { this.storageKey = CONFIG.STORAGE_KEYS.SESSIONS; this.timeout = CONFIG.SESSION_TIME_WINDOW_MS; }
        getSession(personId) { if (!personId) return null; const sessions = this._getSessions(); const session = sessions[personId]; if (!session || (Date.now() - session.lastActivity > this.timeout)) { this.clearSession(personId); return null; } return session; }
        updateSession(personId, turnData) { if (!personId) return; const sessions = this._getSessions(); let session = sessions[personId] || { history: [], insights: [], lastActivity: 0 }; session.history.push({ ...turnData.history, timestamp: Date.now() }); session.insights.push(turnData.insight); session.lastActivity = Date.now(); sessions[personId] = session; this._saveSessions(sessions); }
        clearSession(personId) { if (!personId) return; const sessions = this._getSessions(); delete sessions[personId]; this._saveSessions(sessions); }
        _getSessions() { return JSON.parse(localStorage.getItem(this.storageKey) || '{}'); }
        _saveSessions(sessions) { localStorage.setItem(this.storageKey, JSON.stringify(sessions)); }
    }

    class ProfileStorage {
        constructor() { this.storageKey = CONFIG.STORAGE_KEYS.PROFILES; this.writeQueue = []; this.writeTimer = null; }
        async getPersonProfile(personId) { if (!personId) return null; const p = JSON.parse(localStorage.getItem(this.storageKey) || '{}'); return p[personId] || null; }
        async savePersonProfile(personId, profile) { 
            this.writeQueue.push({ personId, profile });
            if (this.writeTimer) clearTimeout(this.writeTimer);
            this.writeTimer = setTimeout(() => this._flushWrites(), 500);
        }
        async _flushWrites() {
            if (this.writeQueue.length === 0) return;
            const profiles = await this.getAllProfiles();
            this.writeQueue.forEach(({ personId, profile }) => {
                profiles[personId] = this._compressProfile(profile);
            });
            await this.saveAllProfiles(profiles);
            this.writeQueue = [];
            showToast("Profiles saved.", "success", 2000);
        }
        async getAllProfiles() { return JSON.parse(localStorage.getItem(this.storageKey) || '{}'); }
        async saveAllProfiles(profiles) { localStorage.setItem(this.storageKey, JSON.stringify(profiles)); }
        _compressProfile(profile) { return { ...profile, summary: profile.summary?.slice(0, 2000), lastAccessed: Date.now() }; }
    }
    
    class GeminiApiClient {
        constructor(apiKey) { this.apiKey = apiKey; this.baseUrl = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent'; }
        async call(prompt, options = {}) {
            const payload = { contents: [{ parts: [{ text: prompt }] }], generationConfig: { temperature: options.temperature || 0.6, maxOutputTokens: 2048 } };
            if(options.responseSchema) { payload.generationConfig.responseMimeType = "application/json"; payload.generationConfig.responseSchema = options.responseSchema; }
            const responseText = await this._makeRequest(payload);
            try { return JSON.parse(decodeHtmlEntities(responseText)); } catch (e) { console.error("API JSON Parse Error:", responseText); throw new Error("The AI returned an invalid response. Please try again."); }
        }
        async _makeRequest(payload) {
            if (!this.apiKey) throw new Error("API Key not set.");
            for (let attempt = 0; attempt < CONFIG.API_RETRY_COUNT; attempt++) {
                const controller = new AbortController(); const timeoutId = setTimeout(() => controller.abort(), CONFIG.API_TIMEOUT_MS);
                try {
                    const response = await fetch(this.baseUrl, { method: 'POST', headers: { 'X-Goog-Api-Key': this.apiKey, 'Content-Type': 'application/json' }, body: JSON.stringify(payload), signal: controller.signal });
                    clearTimeout(timeoutId);
                    if (!response.ok) { const errorData = await response.json().catch(() => ({})); throw new Error(`API Error ${response.status}: ${errorData.error?.message || response.statusText}`); }
                    const result = await response.json();
                    if (!result.candidates?.[0]?.content?.parts?.[0]?.text) throw new Error('Invalid API response structure received.');
                    return result.candidates[0].content.parts[0].text;
                } catch (error) { clearTimeout(timeoutId); if (attempt === CONFIG.API_RETRY_COUNT - 1 || error.name === 'AbortError') throw error; await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, attempt))); }
            }
            throw new Error("API request failed after multiple retries.");
        }
    }

    class ApiManager {
        constructor() { this.cache = new Map(); this.cacheTimeout = 5 * 60 * 1000; }
        _hashPrompt(prompt, options) {
            const str = JSON.stringify({ prompt, options });
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = (hash << 5) - hash + char;
                hash |= 0; 
            }
            return hash;
        }
        async call(prompt, options = {}) {
            const key = this._hashPrompt(prompt, options);
            const cached = this.cache.get(key);
            if (cached && (Date.now() - cached.timestamp < this.cacheTimeout)) {
                return cached.data;
            }
            const result = await this.getClient().call(prompt, options);

            if (this.cache.size >= CONFIG.API_CACHE_MAX_SIZE) {
                const oldestKey = this.cache.keys().next().value;
                this.cache.delete(oldestKey);
            }
            this.cache.set(key, { data: result, timestamp: Date.now() });
            return result;
        }
        getClient() { if (!state.settings.apiKey) throw new Error("API Key is not available. Please set it in Settings."); return new GeminiApiClient(state.settings.apiKey); }
    }

    class PersonalizedWorkplaceAgent {
        constructor(apiManager, storage, sessionManager) { this.apiManager = apiManager; this.storage = storage; this.sessionManager = sessionManager; this.personProfiles = new LRUCache(CONFIG.PROFILE_CACHE_MAX_SIZE); }
        async analyze(message, userInput, personId, persona) {
            const personProfile = await this.getPersonProfile(personId);
            const session = this.sessionManager.getSession(personId);
            const prompt = this._buildAnalysisPrompt(message, userInput, personProfile, persona, session?.history);
            const result = await this.apiManager.call(prompt, { 
                responseSchema: { type: "OBJECT", properties: { "analysis": { type: "OBJECT", properties: { "insight": { "type": "STRING" }, "strategy": { "type": "STRING" }, "risk": { "type": "STRING", "enum": ["Low", "Medium", "High", "None"] } } }, "responses": { type: "ARRAY", items: { type: "OBJECT", properties: { "title": { "type": "STRING" }, "text": { "type": "STRING" } }, required: ["title", "text"] } } } } 
            });
            if (!validateAIResponse(result)) { throw new Error("AI returned an invalid response. Please try again."); }
            if (personId) {
                const fullUserMessage = [message, userInput].filter(Boolean).join('\n');
                const safeInsight = (result.analysis.insight || '').slice(0, 300);
                this.sessionManager.updateSession(personId, { history: { role: 'user', content: fullUserMessage }, insight: safeInsight });
            }
            return result;
        }
        async summarizeSession(personId) {
            if (!personId) return;
            try {
                const session = this.sessionManager.getSession(personId);
                const profile = await this.getPersonProfile(personId);
                if (!session || !profile || session.insights.length === 0) { this.sessionManager.clearSession(personId); return; }
                
                const prompt = `Update the existing profile with new insights. 
MERGE STRATEGY: Preserve existing insights, add new distinctive patterns only.
EXISTING: ${profile.summary}
NEW INSIGHTS: ${session.insights.join(' ')}
TASK: Return updated summary that preserves existing knowledge while adding new patterns. Respond ONLY with a JSON object with a "summary" key.`;

                const result = await this.apiManager.call(prompt, { temperature: 0.1, responseSchema: { type: "OBJECT", properties: { "summary": { "type": "STRING" } } } });

                const newSummary = result?.summary?.trim();
                if (newSummary && !newSummary.toLowerCase().includes("no significant")) {
                    profile.summary = newSummary;
                    await this.storage.savePersonProfile(personId, profile);
                    this.personProfiles.set(personId, profile);
                }
                this.sessionManager.clearSession(personId);
            } catch (error) { console.error('Session summarization failed:', error); showToast("Failed to save session summary.", "error"); }
        }
        _sanitizePromptInput(content) {
            if (!content) return '';
            return content
                .replace(/[<>]/g, match => ({ '<': '&lt;', '>': '&gt;' }[match]))
                .replace(/\{\{|\}\}/g, '')
                .replace(/```[\s\S]*?```/g, '[CODE_BLOCK_REMOVED]')
                .replace(/(system|assistant|user):/gi, '[ROLE_REMOVED]:')
                .replace(/^\s*(ignore|disregard|forget|override|system|you are|act as|pretend).*$/gmi, '[INSTRUCTION_REMOVED]')
                .slice(0, 1500)
                .replace(/[\x00-\x1f\x7f-\x9f]/g, '');
        }
        _promptHeader(mode, persona) {
            const personaConfig = PERSONA_CONFIGS[persona] || PERSONA_CONFIGS.diplomat;
            return `You are "The Strategic Gatekeeper," an elite AI specializing in workplace communication. Your current persona is "${persona}".
PERSONA TRAITS: ${personaConfig.traits}
TONE: ${personaConfig.tone}
<task>
1.  **Analyze**: Create a concise, single-sentence analysis for "insight" and "strategy". Also provide a "risk" level ("Low", "Medium", "High", or "None").
2.  **Respond**: Generate 3 distinct response options. Each must have a short "title" (1-3 words) and "text".
3.  **Format**: Respond ONLY with valid JSON matching the schema. No extra text or markdown.
</task>`;
        }
        _buildHistoryBlock(sessionHistory) { if (!sessionHistory || sessionHistory.length === 0) return ''; return `<short_term_memory_conversation_history>${sessionHistory.map(h => `${h.role}: ${h.content}`).join('\n')}</short_term_memory_conversation_history>`; }
        _buildContext(personProfile) { return `<context><person_name>${personProfile?.name || 'General'}</person_name><relationship>${personProfile?.type || 'Not specified'}</relationship><long_term_memory_summary>${personProfile?.summary || 'No summary yet.'}</long_term_memory_summary></context>`; }
        _buildUserInput(message, userInput, mode) {
            const sanitizedMessage = this._sanitizePromptInput(message);
            const sanitizedUserInput = this._sanitizePromptInput(userInput);
            if (mode === 'Compose') return `<user_prompt>${sanitizedUserInput}</user_prompt>`;
            return `<message_to_analyze>${sanitizedMessage}</message_to_analyze><user_guidance>${sanitizedUserInput || 'Initial analysis.'}</user_guidance>`;
        }
        _buildAnalysisPrompt(message, userInput, personProfile, persona, sessionHistory) {
            const mode = !message ? 'Compose' : 'Response';
            const maxHistoryItems = 5;
            const recentHistory = sessionHistory ? sessionHistory.slice(-maxHistoryItems) : [];
            const contextPriority = [
                this._buildUserInput(message, userInput, mode),
                this._buildContext(personProfile),
                this._buildHistoryBlock(recentHistory)
            ];
            const fullInput = `<input><mode>${mode}</mode><persona>${persona}</persona>${contextPriority.join('')}</input>`;
            return `${this._promptHeader(mode, persona)}${fullInput}`;
        }
        async getPersonProfile(personId) { 
            if (!personId) return null; 
            const cached = this.personProfiles.get(personId); if (cached) return cached;
            const stored = await this.storage.getPersonProfile(personId); if (stored) { this.personProfiles.set(personId, stored); return stored; } 
            return null; 
        }
    }

    const UIManager = {
        init() { this.setEmptyStateMessages(); },
        openModal(modalElement) { focusedElementBeforeModal = document.activeElement; modalElement.classList.remove('hidden'); activeModal = modalElement; const firstFocusable = modalElement.querySelector('input, button, select, textarea'); if (firstFocusable) firstFocusable.focus(); },
        closeModal(modalElement) { modalElement.classList.add('hidden'); if (activeModal === modalElement) activeModal = null; if (focusedElementBeforeModal) focusedElementBeforeModal.focus(); },
        updateUIState(isLoading = false) {
            const loaderDisplay = isLoading ? 'flex' : 'none';
            dom.translationLoader.style.display = loaderDisplay;
            dom.outputLoader.style.display = loaderDisplay;
            const controlsToLock = [dom.messageInput, dom.userInput, dom.personaSelector, dom.recipientSelector, dom.endConversationBtn, dom.clearInputsBtn];
            controlsToLock.forEach(c => c.disabled = isLoading);
            if (!isLoading) { dom.endConversationBtn.classList.toggle('hidden', !state.selectedPersonId); }
        },
        showProgress(stage) {
            const stages = ['Analyzing input...', 'Generating responses...', 'Finalizing analysis...'];
            const loaderText = dom.translationLoader.querySelector('span:last-child');
            if (loaderText) loaderText.textContent = stages[stage] || 'Processing...';
        },
        showApiKeyCta() { dom.analysisSection.classList.remove('hidden'); dom.responsesSection.classList.add('hidden'); dom.translationResult.classList.add('hidden'); dom.apiKeyCta.classList.remove('hidden'); dom.optionsContainer.replaceChildren(); dom.analysisTitle.textContent = "AI Analysis"; },
        hideApiKeyCta() { dom.translationResult.classList.remove('hidden'); dom.apiKeyCta.classList.add('hidden'); this.setEmptyStateMessages(); },
        setEmptyStateMessages() { dom.translationResult.innerHTML = `<div class="empty-state-text">Analysis will appear here.</div>`; dom.optionsContainer.innerHTML = `<div class="empty-state-text">Responses will appear here.</div>`; },
        displayAnalysis(analysis) {
            dom.translationResult.replaceChildren(); 
            if (!analysis) { dom.translationResult.textContent = 'No analysis available.'; return; }
            const p = (strongText, value, colorClass = '') => {
                const pEl = document.createElement('p');
                const strongEl = document.createElement('strong'); strongEl.textContent = strongText;
                const spanEl = document.createElement('span'); spanEl.textContent = value || 'N/A';
                if (colorClass) spanEl.className = colorClass;
                pEl.append(strongEl, spanEl); return pEl;
            };
            dom.translationResult.append(p('Insight: ', analysis.insight), p('Strategy: ', analysis.strategy), p('Risk: ', analysis.risk, this.getRiskColor(analysis.risk)));
        },
        displayResponses(responses) {
            dom.optionsContainer.replaceChildren();
            if (!Array.isArray(responses)) return;
            responses.forEach((response, index) => {
                const card = document.createElement('div');
                card.className = 'response-card';
                if (index === 0) card.classList.add('primary'); // Make the first one primary by default
                const header = document.createElement('div'); header.className = 'response-card-header';
                const title = document.createElement('h4'); title.textContent = response.title;
                const copyBtn = document.createElement('button'); copyBtn.className = 'copy-btn btn'; copyBtn.textContent = 'Copy'; copyBtn.dataset.text = response.text;
                header.append(title, copyBtn);
                const p = document.createElement('p'); p.textContent = response.text;
                card.append(header, p); dom.optionsContainer.appendChild(card);
            });
        },
        getRiskColor(risk) { const r = (risk || '').toLowerCase(); if (r.includes('high')) return 'text-danger'; if (r.includes('medium')) return 'text-warning'; return 'text-success'; },
        updateAnalysisTitle(mode) { dom.analysisSection.classList.toggle('hidden', mode === 'compose' || !state.settings.apiKey); },
        async populateRecipientSelector(profiles) {
            dom.recipientSelectorContainer.classList.remove('hidden');
            dom.recipientSelector.innerHTML = `<option value="general">-- General Communication --</option>`;
            const grouped = Object.values(profiles).reduce((acc, p) => { (acc[p.type] = acc[p.type] || []).push(p); return acc; }, {});
            CONFIG.STANDARD_RELATIONSHIPS.forEach(type => { if (grouped[type]) { const optgroup = document.createElement('optgroup'); optgroup.label = type; grouped[type].forEach(p => optgroup.appendChild(new Option(p.name, p.id))); dom.recipientSelector.appendChild(optgroup); delete grouped[type]; } });
            const otherTypes = Object.keys(grouped);
            if(otherTypes.length > 0) { const otherGroup = document.createElement('optgroup'); otherGroup.label = 'Other'; otherTypes.forEach(type => { grouped[type].forEach(p => otherGroup.appendChild(new Option(`${p.name} (${p.type})`, p.id))); }); dom.recipientSelector.appendChild(otherGroup); }
            dom.recipientSelector.add(new Option('+ Add New Person', 'add_new_person'));
            dom.recipientSelector.value = state.selectedPersonId || "general";
        },
        async renderPeopleList(profiles) {
            dom.peopleList.replaceChildren();
            Object.values(profiles).forEach(p => { 
                const div = document.createElement('div'); div.className = 'person-item';
                const header = document.createElement('div'); header.className = "person-item-header";
                const nameSpan = document.createElement('span'); nameSpan.textContent = `${p.name} (${p.type})`;
                const controlsDiv = document.createElement('div'); controlsDiv.className = "person-controls";
                const profileBtn = document.createElement('button'); profileBtn.className = "btn view-profile-btn"; profileBtn.dataset.id = p.id; profileBtn.textContent = "Profile";
                const delBtn = document.createElement('button'); delBtn.className = "btn btn-danger"; delBtn.dataset.id = p.id; delBtn.textContent = "Delete";
                controlsDiv.append(profileBtn, delBtn); header.append(nameSpan, controlsDiv); div.append(header); dom.peopleList.appendChild(div); 
            });
        },
        toggleProfileAccordion(personItem, personProfile) {
            const existingDetails = personItem.querySelector('.profile-details');
            if (existingDetails) { existingDetails.remove(); return; }
            const detailsDiv = document.createElement('div'); detailsDiv.className = 'profile-details';
            detailsDiv.innerHTML = `<h4>AI Summary</h4>`;
            const summaryText = personProfile.summary || '';
            const textarea = document.createElement('textarea'); textarea.id = `summary-${personProfile.id}`; textarea.className = 'input-field'; textarea.rows = 6; textarea.value = summaryText;
            const charCountP = document.createElement('p'); charCountP.className = 'summary-char-count'; charCountP.id = `count-${personProfile.id}`; charCountP.textContent = `${summaryText.length} chars`;
            textarea.addEventListener('input', () => { charCountP.textContent = `${textarea.value.length} chars`; });
            const actionsDiv = document.createElement('div'); actionsDiv.className = 'modal-actions'; actionsDiv.style.marginTop = '0.5rem';
            const saveBtn = document.createElement('button'); saveBtn.className = "btn btn-primary save-profile-btn"; saveBtn.dataset.id = personProfile.id; saveBtn.textContent = "Save Profile";
            actionsDiv.appendChild(saveBtn); detailsDiv.append(textarea, charCountP, actionsDiv); personItem.appendChild(detailsDiv);
        },
    };
    
    const storage = new ProfileStorage();
    const sessionManager = new SessionManager();
    const apiManager = new ApiManager();
    const agent = new PersonalizedWorkplaceAgent(apiManager, storage, sessionManager);

    function queueRender() { if (!renderQueued) { renderQueued = true; requestAnimationFrame(() => { renderQueued = false; UIManager.updateUIState(); }); } }

    async function handleResponseRefinement() {
        if (!state.lastAnalysis) return;
        UIManager.updateUIState(true); dom.outputLoader.style.display = 'flex'; dom.optionsContainer.replaceChildren();
        try { const result = await agent.analyze(state.detectedMessage, dom.userInput.value, state.selectedPersonId, state.selectedPersona); UIManager.displayResponses(result.responses);
        } catch (error) { showToast(error.message, 'error');
        } finally { UIManager.updateUIState(false); dom.outputLoader.style.display = 'none'; }
    }

    async function handleFullAnalysis() {
        if (!state.settings.apiKey) { UIManager.showApiKeyCta(); return; }
        const hasText = state.detectedMessage.trim().length > 0 || dom.userInput.value.trim().length > 0; if (!hasText) return;
        UIManager.updateUIState(true); UIManager.showProgress(0); dom.analysisSection.classList.remove('hidden'); dom.responsesSection.classList.remove('hidden'); dom.translationResult.textContent = ''; dom.optionsContainer.replaceChildren(); state.lastAnalysis = null;
        try { 
            const resultPromise = agent.analyze(state.detectedMessage, dom.userInput.value, state.selectedPersonId, state.selectedPersona);
            UIManager.showProgress(1);
            const result = await resultPromise;
            UIManager.showProgress(2);
            state.lastAnalysis = result.analysis; UIManager.displayAnalysis(result.analysis); UIManager.displayResponses(result.responses);
        } catch(error) { showToast(error.message, 'error'); dom.translationResult.textContent = 'An error occurred during analysis.';
        } finally { UIManager.updateUIState(false); }
    }

    function migrateStorage() { for (const keyType in CONFIG.OLD_STORAGE_KEYS) { const newKey = CONFIG.STORAGE_KEYS[keyType]; for (const oldKey of CONFIG.OLD_STORAGE_KEYS[keyType]) { const oldData = localStorage.getItem(oldKey); if (oldData) { if (!localStorage.getItem(newKey)) { localStorage.setItem(newKey, oldData); } localStorage.removeItem(oldKey); } } } }
    function loadSettings() { migrateStorage(); const saved = JSON.parse(localStorage.getItem(CONFIG.STORAGE_KEYS.SETTINGS) || '{}'); state.settings.onboardingDismissed = saved.onboardingDismissed || false; state.settings.apiKey = saved.apiKey || null; }
    async function saveSettings() {
        state.settings.apiKey = dom.geminiApiKeyInput.value;
        const wasApiKeyMissing = !state.settings.apiKey;
        localStorage.setItem(CONFIG.STORAGE_KEYS.SETTINGS, JSON.stringify({ onboardingDismissed: true, apiKey: state.settings.apiKey }));
        UIManager.closeModal(dom.settingsModal);
        if (state.settings.apiKey) { UIManager.hideApiKeyCta(); if (wasApiKeyMissing) { dom.translationResult.innerHTML = `<div class="empty-state-text"><strong>API key set!</strong> Paste a message to get started.</div>`; }
        } else { UIManager.showApiKeyCta(); }
        queueRender();
    }
    function renderSettings() { dom.geminiApiKeyInput.value = state.settings.apiKey || ''; }
    function isInsideSidebar() { return window.innerWidth <= CONFIG.SIDEBAR_MAX_WIDTH; }

    async function initializeApp() {
        let debouncedRefinement;
        UIManager.init();
        await UIManager.populateRecipientSelector(await storage.getAllProfiles());
        
        if (debouncedRefinement) debouncedRefinement.cancel?.();
        debouncedRefinement = debounce(handleResponseRefinement, CONFIG.DEBOUNCE_MS_FAST);

        const updateUIMode = () => {
            const hasMessage = dom.messageInput.value.trim().length > 0;
            dom.userInputTitle.textContent = hasMessage ? "Add Context to Refine Responses" : "Compose Your Message";
            dom.userInput.placeholder = hasMessage ? "e.g., 'make it more formal'" : "e.g., 'email my team about the deadline'";
            dom.analyzeBtn.disabled = !hasMessage && !dom.userInput.value.trim().length > 0;
            UIManager.updateAnalysisTitle(hasMessage ? 'analyze' : 'compose');
        };

        dom.messageInput.addEventListener('input', () => { state.detectedMessage = dom.messageInput.value; updateUIMode(); });
        dom.userInput.addEventListener('input', () => { const hasMessage = dom.messageInput.value.trim().length > 0; if (hasMessage) { debouncedRefinement(); } else { updateUIMode(); } });
        dom.userInput.addEventListener('keydown', (e) => { if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') { e.preventDefault(); dom.analyzeBtn.click(); } });
        
        dom.userInput.addEventListener('blur', () => {
            const hasContent = dom.messageInput.value.trim().length > 0 || dom.userInput.value.trim().length > 0;
            // Avoid triggering if an analysis is already running or a modal is open.
            if (hasContent && !operationInProgress && !activeModal) {
                handleFullAnalysis();
            }
        });

        dom.analyzeBtn.addEventListener('click', () => handleFullAnalysis());
        dom.personaSelector.addEventListener('change', (e) => { state.selectedPersona = e.target.value; if (state.lastAnalysis) { handleResponseRefinement(); } });
        
        dom.recipientSelector.addEventListener('change', async (e) => {
            if (operationInProgress) return;
            const switchId = Symbol();
            pendingPersonSwitch = switchId;

            const newPersonId = e.target.value;
            if (newPersonId === 'add_new_person') {
                dom.newPersonRelationshipType.innerHTML = '';
                [...CONFIG.STANDARD_RELATIONSHIPS, "Other"].forEach(r => dom.newPersonRelationshipType.add(new Option(r,r)));
                dom.customRoleGroup.classList.add('hidden');
                await UIManager.renderPeopleList(await storage.getAllProfiles());
                UIManager.openModal(dom.peopleModal);
                dom.recipientSelector.value = state.selectedPersonId || "general";
                return;
            }
            
            operationInProgress = true;
            UIManager.updateUIState(true);
            try {
                if (state.selectedPersonId) await agent.summarizeSession(state.selectedPersonId);
                if (pendingPersonSwitch !== switchId) return; // FIX: Second check after async operation to prevent race condition.
                state.selectedPersonId = newPersonId === 'general' ? null : newPersonId;
            } catch (error) { console.warn('Failed to summarize session on person change:', error);
            } finally { operationInProgress = false; UIManager.updateUIState(false); }
        });

        dom.clearInputsBtn.addEventListener('click', () => { state.detectedMessage = ''; dom.messageInput.value = ''; dom.userInput.value = ''; state.lastAnalysis = null; if(state.settings.apiKey) UIManager.hideApiKeyCta(); else UIManager.showApiKeyCta(); dom.optionsContainer.replaceChildren(); dom.analysisSection.classList.add('hidden'); dom.responsesSection.classList.add('hidden'); updateUIMode(); });
        dom.endConversationBtn.addEventListener('click', async () => { UIManager.updateUIState(true); await agent.summarizeSession(state.selectedPersonId); UIManager.updateUIState(false); });

        dom.settingsBtn.addEventListener('click', () => { renderSettings(); UIManager.openModal(dom.settingsModal); });
        dom.ctaSettingsBtn.addEventListener('click', () => dom.settingsBtn.click());
        dom.cancelSettingsBtn.addEventListener('click', () => UIManager.closeModal(dom.settingsModal));
        dom.saveSettingsBtn.addEventListener('click', saveSettings);
        dom.managePeopleSettingsBtn.addEventListener('click', () => {
            UIManager.closeModal(dom.settingsModal);
            dom.newPersonRelationshipType.innerHTML = '';
            [...CONFIG.STANDARD_RELATIONSHIPS, "Other"].forEach(r => dom.newPersonRelationshipType.add(new Option(r,r)));
            dom.customRoleGroup.classList.add('hidden');
            UIManager.renderPeopleList(storage.getAllProfiles()).then(() => UIManager.openModal(dom.peopleModal));
        });
        dom.clearDataBtn.addEventListener('click', async () => { if(await showConfirmationModal('Clear Data', 'Are you sure you want to delete ALL local data? This is irreversible.')) { Object.values(CONFIG.STORAGE_KEYS).forEach(key => localStorage.removeItem(key)); window.location.reload(); } });
        
        dom.closePeopleBtn.addEventListener('click', () => UIManager.closeModal(dom.peopleModal));
        dom.newPersonRelationshipType.addEventListener('change', e => dom.customRoleGroup.classList.toggle('hidden', e.target.value !== 'Other'));
        dom.addPersonBtn.addEventListener('click', async () => {
            const name = dom.newPersonName.value.trim();
            let role = dom.newPersonRelationshipType.value;
            if (role === 'Other') role = dom.newPersonRole.value.trim();
            if (!name || !role) { showToast("Name and Relationship are required.", "error"); return; }
            const id = `person_${Date.now()}`; 
            await storage.savePersonProfile(id, { id, name, type: role, summary: `Profile for ${name}.` });
            dom.newPersonName.value = ''; dom.newPersonRole.value = '';
            const allProfiles = await storage.getAllProfiles();
            await UIManager.renderPeopleList(allProfiles);
            await UIManager.populateRecipientSelector(allProfiles);
        });

        dom.peopleList.addEventListener('click', async (e) => {
            const button = e.target.closest('button'); if (!button) return;
            const personId = button.dataset.id; const personItem = button.closest('.person-item');
            if (button.classList.contains('view-profile-btn')) { const profile = await storage.getPersonProfile(personId); if(profile) UIManager.toggleProfileAccordion(personItem, profile); } 
            else if (button.classList.contains('btn-danger')) { if (await showConfirmationModal("Delete Person", "Are you sure? This cannot be undone.")) { const profiles = await storage.getAllProfiles(); delete profiles[personId]; await storage.saveAllProfiles(profiles); if (state.selectedPersonId === personId) state.selectedPersonId = null; await UIManager.renderPeopleList(profiles); await UIManager.populateRecipientSelector(profiles); } }
            else if (button.classList.contains('save-profile-btn')) {
                const summaryTextarea = personItem.querySelector(`#summary-${personId}`);
                const profile = await storage.getPersonProfile(personId); if (!profile) return;
                profile.summary = summaryTextarea.value; await storage.savePersonProfile(personId, profile);
                await UIManager.populateRecipientSelector(await storage.getAllProfiles());
                button.textContent = 'Saved!'; setTimeout(() => { button.textContent = 'Save Profile'; }, 2000);
            }
        });

        document.body.addEventListener('click', (e) => { const button = e.target.closest('.copy-btn'); if (button) { navigator.clipboard.writeText(button.dataset.text).then(() => { showToast("Copied to clipboard!", "success"); }).catch(err => { console.error("Failed to copy:", err); showToast("Could not copy text.", "error"); }); } });
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && activeModal) {
                // FIX: Specifically handle the confirmation modal on Escape to ensure cleanup.
                if (activeModal === dom.confirmModal) {
                    dom.confirmCancelBtn.click();
                } else {
                    UIManager.closeModal(activeModal);
                }
            }
            if (e.key === 'Tab' && activeModal) {
                const els = activeModal.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
                const first = els[0], last = els[els.length - 1];
                if (e.shiftKey) { if (document.activeElement === first) { last.focus(); e.preventDefault(); } } 
                else { if (document.activeElement === last) { first.focus(); e.preventDefault(); } }
            }
        });
        updateUIMode();
        queueRender();
    }
    
    async function main() {
        loadSettings();
        if (!isInsideSidebar() && !state.settings.onboardingDismissed) {
            dom.onboardingOverlay.classList.remove('hidden');
            dom.dismissOnboardingBtn.addEventListener('click', () => {
                state.settings.onboardingDismissed = true;
                localStorage.setItem(CONFIG.STORAGE_KEYS.SETTINGS, JSON.stringify(state.settings));
                dom.onboardingOverlay.classList.add('hidden');
                dom.app.classList.remove('hidden');
                initializeApp().then(() => { if (!state.settings.apiKey) UIManager.showApiKeyCta(); }).catch(console.error);
            }, { once: true });
        } else {
            dom.app.classList.remove('hidden');
            await initializeApp();
            if (!state.settings.apiKey) UIManager.showApiKeyCta();
        }
    }
    
    main().catch(console.error);
    </script>
</body>
</html>

