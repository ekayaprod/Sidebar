<!DOCTYPE html>
<!-- LLM-NOTE: This application is optimized exclusively for Microsoft Edge. Do not add cross-browser compatibility code. -->
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sidebar</title>
    <style>
        /* LLM-NOTE: All styling is self-contained. Do not introduce external CSS frameworks. */
        :root {
            --bg-color: #f4f7fa; --panel-bg: #ffffff; --border-color: #e2e8f0;
            --text-color: #1e293b; --subtle-text: #64748b; --primary-color: #3b82f6;
            --danger-color: #ef4444; --success-color: #22c55e; --warning-color: #f97316;
            --info-bg: #f8fafc; --danger-hover-bg: #fee2e2;
            --font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg-color: #111827; --panel-bg: #1f2937; --border-color: #374151;
                --text-color: #f9fafb; --subtle-text: #9ca3af; --primary-color: #60a5fa;
                --info-bg: #111827; --danger-hover-bg: #4b1d1d;
            }
        }

        html, body { height: 100%; margin: 0; }
        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            font-size: 14px;
            display: flex;
        }

        /* --- Layout & Core Components --- */
        #app { width: 100%; height: 100vh; display: flex; flex-direction: column; padding: 0.75rem; box-sizing: border-box; gap: 0.5rem; }
        main { flex-grow: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 0.5rem; padding-right: 4px; }
        .section { background-color: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 0.5rem; padding: 0.5rem; }
        .section-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.4rem; }
        .section-title { font-size: 0.9rem; font-weight: 600; margin: 0; white-space: nowrap; }
        .input-field, select { width: 100%; box-sizing: border-box; font-size: 0.875rem; padding: 0.4rem 0.6rem; border-radius: 0.375rem; border: 1px solid var(--border-color); font-family: inherit; background-color: var(--info-bg); color: var(--text-color); }
        .input-field:focus, select:focus { outline: 2px solid var(--primary-color); outline-offset: -1px; background-color: var(--panel-bg); }
        textarea.input-field { resize: vertical; }

        /* --- Buttons & Controls --- */
        .btn { padding: 0.35rem 0.6rem; font-size: 0.8rem; border: 1px solid var(--border-color); border-radius: 0.375rem; cursor: pointer; background-color: var(--panel-bg); transition: background-color 0.2s; font-weight: 500; color: var(--text-color); }
        .section-header .controls .btn, .section-header .controls select { padding-top: 0.2rem; padding-bottom: 0.2rem; font-size: 0.75rem; }
        .btn:hover { background-color: var(--info-bg); }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; }
        .btn-primary { background-color: var(--primary-color); color: white; border-color: var(--primary-color); }
        .btn-primary:hover { filter: brightness(110%); }
        .btn-danger { background-color: var(--danger-color); color: white; border-color: var(--danger-color); }
        .btn-danger:hover { filter: brightness(110%); }
        #clearInputsBtn, #settingsBtn, #globalManagePeopleBtn { background: none; border: none; font-size: 0.75rem; color: var(--subtle-text); cursor: pointer; padding: 0.2rem; }
        #settingsBtn, #globalManagePeopleBtn { font-size: 1.1rem; }
        #clearInputsBtn:hover, #settingsBtn:hover, #globalManagePeopleBtn:hover { color: var(--text-color); }
        
        #ephemeralBadge { font-size: 0.65rem; font-weight: 700; background-color: var(--warning-color); color: white; padding: 0.1rem 0.4rem; border-radius: 1rem; text-transform: uppercase; letter-spacing: 0.05em; }

        /* --- Specific UI Sections --- */
        .controls { display: flex; align-items: center; gap: 0.5rem; }
        .section-header .controls { flex-grow: 1; justify-content: flex-end; flex-wrap: nowrap; }
        textarea#messageInput { min-height: 60px; max-height: 120px; }
        #relationshipTypeSelector { flex-basis: 120px; flex-shrink: 1; }
        #personSelectorContainer { display: flex; flex-grow: 1; gap: 0.5rem; align-items: center; min-width: 100px; }
        #personSelector { flex-grow: 1; }
        #personaSelector { max-width: 120px; }
        .loader { display: none; align-items: center; gap: 0.5rem; font-size: 0.875rem; color: var(--subtle-text); }
        .loader-dot { animation: pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

        /* --- Analysis & Response Display --- */
        #analysisSection { transition: all 0.3s ease-in-out; }
        #translationResult { font-size: 0.875rem; color: var(--text-color); padding: 0.75rem; border-radius: 0.375rem; background-color: var(--info-bg); }
        #apiKeyCta { text-align: center; padding: 1rem; background-color: var(--info-bg); border-radius: .5rem; }
        #apiKeyCta p { margin: 0 0 0.75rem 0; color: var(--text-color); }
        .prose-styles p { margin: 0 0 0.75rem; line-height: 1.5; color: var(--text-color); }
        .prose-styles strong { color: var(--subtle-text); font-weight: 600; }
        .empty-state-text { color: var(--subtle-text); text-align: center; padding: 1rem; }
        #optionsContainer { display: flex; flex-direction: column; gap: 0.5rem; margin-top: 0.75rem; }
        .response-card { padding: 0.75rem; border-radius: 0.375rem; background-color: var(--panel-bg); border: 1px solid var(--border-color); }
        .response-card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; }
        .response-card-header h4 { font-size: 0.8rem; font-weight: 700; color: var(--primary-color); }
        .response-card p { font-size: 0.875rem; color: var(--text-color); margin: 0; white-space: pre-wrap; white-space: pre-line; }
        #errorContainer { padding: 0.5rem; text-align: center; color: var(--danger-color); font-size: 0.875rem; }
        #errorContainer button { font-size: inherit; text-decoration: underline; background: none; border: none; color: var(--primary-color); cursor: pointer; padding: 0; }

        /* --- Modals & Overlays --- */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(100,116,139,0.5); display: flex; align-items: center; justify-content: center; z-index: 1000; backdrop-filter: blur(4px); }
        .modal-content { background: var(--panel-bg); padding: 1.5rem; border-radius: 0.75rem; max-width: 95%; width: 420px; box-shadow: 0 10px 25px -5px rgba(0,0,0,0.1); border: 1px solid var(--border-color); display: flex; flex-direction: column; max-height: 90vh; }
        .modal-content h2 { margin: 0 0 1rem 0; font-size: 1.25rem; }
        .modal-content h3 { margin: 0 0 0.5rem 0; font-size: 0.9rem; font-weight: 600; }
        .modal-actions { display: flex; justify-content: flex-end; gap: 0.5rem; margin-top: 1.5rem; flex-shrink: 0; }
        #peopleList .person-item { display: flex; flex-direction: column; padding: 0.5rem; background-color: var(--info-bg); border-radius: 0.25rem; }
        .person-item-header { display: flex; justify-content: space-between; align-items: center; }
        #peopleList .person-controls { display: flex; gap: 0.5rem; }
        #peopleList { display: flex; flex-direction: column; gap: 0.5rem; max-height: 240px; overflow-y: auto; }
        .form-group { margin-bottom: 1rem; }
        .form-group label, .form-group p, .help-link { display: block; margin-bottom: 0.25rem; font-size: 0.875rem; }
        .form-group p { font-size: 0.75rem; color: var(--subtle-text); margin-top: 0.25rem; }
        .help-link { color: var(--primary-color); text-decoration: none; margin-top: 0.5rem; }
        .profile-details { margin-top: 0.75rem; border-top: 1px solid var(--border-color); padding-top: 0.75rem; }
        .profile-details h4 { font-size: 0.8rem; font-weight: 600; margin: 0 0 0.5rem 0; }
        .summary-warning { font-size: 0.75rem; color: var(--warning-color); margin-bottom: 0.5rem; }
        .summary-char-count { font-size: 0.75rem; color: var(--subtle-text); text-align: right; }
        .form-group .error-message { font-size: 0.75rem; color: var(--danger-color); margin-top: 0.25rem; }
        
        #onboardingOverlay { position: fixed; inset: 0; background: var(--bg-color); z-index: 2000; padding: 2rem; color: var(--text-color); }
        #onboardingContent { max-width: 600px; margin: auto; }
        #onboardingContent h1 { font-size: 1.5rem; margin-bottom: 1rem; }
        #onboardingContent p, #onboardingContent li { line-height: 1.6; margin-bottom: 1rem; }
        #onboardingContent ol { padding-left: 1.5rem; }
        #onboardingContent kbd { background: var(--border-color); padding: 0.1rem 0.4rem; border-radius: 0.25rem; font-family: monospace; }
        
        .hidden { display: none !important; }

        .text-success { color: var(--success-color); }
        .text-warning { color: var(--warning-color); }
        .text-danger { color: var(--danger-color); }

        .toggle-switch { position: relative; display: inline-block; width: 44px; height: 24px; vertical-align: middle; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .toggle-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--border-color); transition: .4s; border-radius: 24px; }
        .toggle-slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .toggle-slider { background-color: var(--primary-color); }
        input:checked + .toggle-slider:before { transform: translateX(20px); }
    </style>
</head>
<body>
    <div id="onboardingOverlay" class="hidden">
        <div id="onboardingContent">
            <h1>Welcome to Sidebar</h1>
            <p>This application is designed to run in the Microsoft Edge sidebar for the best experience.</p>
            <h3>Recommended Setup:</h3>
            <ol>
                <li><strong>Enable the Sidebar:</strong> In Edge, go to Settings (`...`) > `Sidebar`, or press <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>/</kbd>.</li>
                <li><strong>Add This App:</strong> In the sidebar, click the `+` icon, find this app under "Open tabs," and pin it.</li>
                <li><strong>Set Your API Key:</strong> To activate the AI, you need a Google AI API key. You can add this in the app's settings (‚öôÔ∏è). <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener" class="help-link">Get your key here.</a></li>
                <li><strong>Keyboard Shortcut:</strong> Press <kbd>Ctrl</kbd> + <kbd>Enter</kbd> in the context box to trigger analysis.</li>
            </ol>
            <button id="dismissOnboardingBtn" class="btn btn-primary" style="margin-top: 1rem;">Continue to App</button>
        </div>
    </div>

    <div id="app" class="hidden">
        <main>
            <section class="section">
                <div class="section-header">
                    <h2 class="section-title">Received Message</h2>
                     <div class="controls">
                        <span id="ephemeralBadge" class="hidden">Ephemeral</span>
                        <span id="clipboardStatus"></span>
                        <label class="toggle-switch"><input type="checkbox" id="clipboardToggle"><span class="toggle-slider"></span></label>
                        <button id="clearInputsBtn" aria-label="Clear all inputs">Clear</button>
                        <button id="globalManagePeopleBtn" title="Manage People" aria-label="Manage People">üë•</button>
                        <button id="settingsBtn" title="Settings" aria-label="Open settings">‚öôÔ∏è</button>
                    </div>
                </div>
                <textarea id="messageInput" class="input-field" placeholder="Paste a message here to get started..."></textarea>
            </section>
            
            <section class="section">
                <div class="section-header">
                    <h2 class="section-title">Your Goal or Message</h2>
                    <div id="contextControls" class="controls">
                        <select id="relationshipTypeSelector" title="Telling the AI your relationship helps it tailor the tone.">
                            <option value="">Select Relationship...</option>
                            <option value="Manager">Manager</option>
                            <option value="Teammate">Teammate</option>
                            <option value="Client">Client</option>
                            <option value="Direct Report">Direct Report</option>
                            <option value="Stakeholder">Stakeholder</option>
                            <option value="Vendor">Vendor</option>
                            <option value="Other">Other</option>
                        </select>
                        <div id="personSelectorContainer" class="hidden">
                            <select id="personSelector"></select>
                        </div>
                         <button id="endConversationBtn" class="btn hidden" title="Summarizes this conversation and adds it to the person's long-term profile.">Save Session</button>
                    </div>
                </div>
                <textarea id="userInput" class="input-field" rows="2" placeholder="Add context for a reply, or compose a new message..."></textarea>
            </section>

            <section id="analysisSection" class="section">
                <div class="section-header">
                    <h2 id="analysisTitle" class="section-title">AI Analysis</h2>
                    <div id="translationLoader" class="loader"><span class="loader-dot">‚óè</span><span>Analyzing...</span></div>
                </div>
                <div id="translationResult" class="prose-styles"></div>
                <div id="apiKeyCta" class="hidden">
                    <p>Please set your API key to enable AI features.</p>
                    <button id="ctaSettingsBtn" class="btn btn-primary">Open Settings</button>
                </div>
            </section>

            <section class="section">
                <div class="section-header">
                    <h2 class="section-title">Suggested Responses</h2>
                    <div class="controls">
                        <select id="personaSelector" title="Choose a persona to change the communication style.">
                            <option value="gatekeeper" title="Protects your time and manages expectations.">Gatekeeper</option>
                            <option value="diplomat" selected title="Prioritizes harmony and de-escalates tension.">Diplomat</option>
                            <option value="challenger" title="Sets clear boundaries and respectfully pushes back.">Challenger</option>
                            <option value="strategist" title="Thinks two steps ahead to position you for success.">Strategist</option>
                        </select>
                        <div id="outputLoader" class="loader"><span class="loader-dot">‚óè</span><span>Generating...</span></div>
                    </div>
                </div>
                <div id="optionsContainer"></div>
                <div id="errorContainer" class="hidden"></div>
            </section>
        </main>
    </div>

    <!-- Modals -->
    <div id="settingsModal" class="modal-overlay hidden" role="dialog" aria-modal="true">
       <div class="modal-content">
            <h2>Settings</h2>
            <div class="form-group">
                <label for="geminiApiKeyInput">Google AI API Key</label>
                <input type="password" id="geminiApiKeyInput" class="input-field" placeholder="Enter your API key">
                <p>Your key is stored in this browser's local storage. Do not use this on a shared computer.</p>
                <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener" class="help-link">How to get a Google AI API key?</a>
            </div>
             <div class="form-group">
                <label style="display: flex; align-items: center; gap: 0.5rem;">
                    <label class="toggle-switch"><input type="checkbox" id="ephemeralToggle"><span class="toggle-slider"></span></label>
                    <span>Ephemeral Mode</span>
                </label>
                 <p>When enabled, all profiles and session data are cleared when you close the app. Settings are still saved.</p>
             </div>
             <div class="form-group" style="border-top: 1px solid var(--border-color); padding-top: 1rem;">
                <label>Data Management</label>
                <button id="clearDataBtn" class="btn btn-danger">Clear All Local Data</button>
                <p>This will permanently delete all saved profiles and session history from this browser.</p>
             </div>
            <div class="modal-actions">
                <button id="cancelSettingsBtn" class="btn">Cancel</button>
                <button id="saveSettingsBtn" class="btn btn-primary">Save</button>
            </div>
        </div>
    </div>
    <div id="peopleModal" class="modal-overlay hidden" role="dialog" aria-modal="true">
       <div class="modal-content">
            <h2>Manage People</h2>
            <div class="form-group">
                <h3>Add New Person</h3>
                <input type="text" id="newPersonName" class="input-field" placeholder="Person's Name" style="margin-bottom: 0.5rem;">
                <div id="customRoleGroup" class="form-group hidden">
                    <input type="text" id="newPersonRole" class="input-field" placeholder="Specify Relationship (e.g., Contractor)">
                </div>
                <button id="addPersonBtn" class="btn btn-primary">Add</button>
            </div>
            <div id="peopleList"></div>
            <div class="modal-actions">
                <button id="closePeopleBtn" class="btn">Close</button>
            </div>
        </div>
    </div>
     <div id="confirmModal" class="modal-overlay hidden" role="dialog" aria-modal="true">
       <div class="modal-content">
            <h2 id="confirmTitle">Confirm Action</h2>
            <p id="confirmMessage" style="line-height: 1.5;"></p>
            <div class="modal-actions">
                <button id="confirmCancelBtn" class="btn">Cancel</button>
                <button id="confirmOkBtn" class="btn btn-danger">OK</button>
            </div>
        </div>
    </div>
    
    <script type="module">
    'use strict';

    const CONFIG = {
        SESSION_TIME_WINDOW_MS: 10 * 60 * 1000,
        STORAGE_KEYS: { 
            PROFILES: 'sidebar_person_profiles_v10', 
            SESSIONS: 'sidebar_conversation_sessions_v4', 
            SETTINGS: 'sidebar_settings_v5' 
        },
        OLD_STORAGE_KEYS: {
            PROFILES: ['sidebar_person_profiles_v9', 'sidebar_person_profiles_v8'],
            SESSIONS: ['sidebar_conversation_sessions_v3', 'sidebar_conversation_sessions_v2'],
            SETTINGS: ['sidebar_settings_v4']
        },
        API_RETRY_COUNT: 2, API_TIMEOUT_MS: 15000,
        SIDEBAR_MAX_WIDTH: 400,
        PROFILE_SUMMARY_WARNING_LENGTH: 1500,
        DEBOUNCE_MS: 500,
        CLIPBOARD_POLL_MS: 2000,
        STANDARD_RELATIONSHIPS: ["Manager", "Teammate", "Client", "Direct Report", "Stakeholder", "Vendor"],
        PROFILE_CACHE_MAX_SIZE: 50,
    };

    const dom = {
        app: document.getElementById('app'), onboardingOverlay: document.getElementById('onboardingOverlay'), dismissOnboardingBtn: document.getElementById('dismissOnboardingBtn'),
        messageInput: document.getElementById('messageInput'), userInput: document.getElementById('userInput'),
        clipboardToggle: document.getElementById('clipboardToggle'), personSelector: document.getElementById('personSelector'),
        relationshipTypeSelector: document.getElementById('relationshipTypeSelector'),
        personaSelector: document.getElementById('personaSelector'),
        personSelectorContainer: document.getElementById('personSelectorContainer'),
        clearInputsBtn: document.getElementById('clearInputsBtn'), settingsBtn: document.getElementById('settingsBtn'),
        globalManagePeopleBtn: document.getElementById('globalManagePeopleBtn'), clipboardStatus: document.getElementById('clipboardStatus'),
        ephemeralBadge: document.getElementById('ephemeralBadge'),
        translationLoader: document.getElementById('translationLoader'), translationResult: document.getElementById('translationResult'),
        analysisTitle: document.getElementById('analysisTitle'),
        apiKeyCta: document.getElementById('apiKeyCta'), ctaSettingsBtn: document.getElementById('ctaSettingsBtn'),
        outputLoader: document.getElementById('outputLoader'), optionsContainer: document.getElementById('optionsContainer'),
        errorContainer: document.getElementById('errorContainer'), 
        contextControls: document.getElementById('contextControls'), endConversationBtn: document.getElementById('endConversationBtn'),
        settingsModal: document.getElementById('settingsModal'), geminiApiKeyInput: document.getElementById('geminiApiKeyInput'),
        ephemeralToggle: document.getElementById('ephemeralToggle'),
        clearDataBtn: document.getElementById('clearDataBtn'),
        saveSettingsBtn: document.getElementById('saveSettingsBtn'), cancelSettingsBtn: document.getElementById('cancelSettingsBtn'), 
        peopleModal: document.getElementById('peopleModal'), peopleList: document.getElementById('peopleList'), 
        newPersonName: document.getElementById('newPersonName'), addPersonBtn: document.getElementById('addPersonBtn'), 
        customRoleGroup: document.getElementById('customRoleGroup'), newPersonRole: document.getElementById('newPersonRole'),
        closePeopleBtn: document.getElementById('closePeopleBtn'),
        analysisSection: document.getElementById('analysisSection'),
        confirmModal: document.getElementById('confirmModal'), confirmTitle: document.getElementById('confirmTitle'), confirmMessage: document.getElementById('confirmMessage'),
        confirmCancelBtn: document.getElementById('confirmCancelBtn'), confirmOkBtn: document.getElementById('confirmOkBtn'),
    };

    let state = {
        detectedMessage: '', lastClipboardContent: '', isClipboardMonitoringActive: false,
        selectedPersonId: null, selectedRelationshipType: null, selectedPersona: 'diplomat',
        ephemeralMode: false,
        settings: { apiKey: null, onboardingDismissed: false },
    };

    let activeModal = null;
    let focusedElementBeforeModal = null;

    const debounce = (fn, delay) => {
        let t;
        return (...args) => {
            clearTimeout(t);
            t = setTimeout(() => fn(...args), delay);
        };
    };
    function sanitizeText(str) { if (!str) return ''; return str.replace(/[&<>"']/g, (match) => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#x27;' }[match])); }

    function showConfirmationModal(title, message) {
        return new Promise((resolve) => {
            dom.confirmTitle.textContent = title;
            dom.confirmMessage.textContent = message;
            UIManager.openModal(dom.confirmModal);

            const handleConfirm = () => { cleanup(); resolve(true); };
            const handleCancel = () => { cleanup(); resolve(false); };

            const cleanup = () => {
                dom.confirmOkBtn.removeEventListener('click', handleConfirm);
                dom.confirmCancelBtn.removeEventListener('click', handleCancel);
                UIManager.closeModal(dom.confirmModal);
            };

            dom.confirmOkBtn.addEventListener('click', handleConfirm, { once: true });
            dom.confirmCancelBtn.addEventListener('click', handleCancel, { once: true });
        });
    }

    function validateAIResponse(response) {
      if (!response || typeof response !== 'object') return false;
      if (!response.analysis || typeof response.analysis !== 'object') return false;
      if (!Array.isArray(response.responses)) return false;
      const requiredAnalysisFields = ['insight', 'strategy'];
      if (!requiredAnalysisFields.every(field => typeof response.analysis[field] === 'string')) return false;
      return response.responses.every(r => r && typeof r.title === 'string' && typeof r.text === 'string' && r.title.length > 0 && r.text.length > 0);
    }

    class SessionManager {
        constructor() { this.storageKey = CONFIG.STORAGE_KEYS.SESSIONS; this.timeout = CONFIG.SESSION_TIME_WINDOW_MS; }
        _shouldPersist() { return !state.ephemeralMode; }
        getSession(personId) {
            if (!this._shouldPersist() || !personId) return null;
            const sessions = this._getSessions();
            const session = sessions[personId];
            if (!session || (Date.now() - session.lastActivity > this.timeout)) {
                this.clearSession(personId);
                return null;
            }
            return session;
        }
        updateSession(personId, turnData) { 
            if (!this._shouldPersist() || !personId) return; 
            const sessions = this._getSessions(); 
            let session = sessions[personId] || { history: [], insights: [], lastActivity: 0 }; 
            session.history.push({ ...turnData.history, timestamp: Date.now() }); 
            session.insights.push(turnData.insight);
            session.lastActivity = Date.now();
            sessions[personId] = session; 
            this._saveSessions(sessions); 
        }
        clearSession(personId) { if (!this._shouldPersist() || !personId) return; const sessions = this._getSessions(); delete sessions[personId]; this._saveSessions(sessions); }
        _getSessions() { return JSON.parse(localStorage.getItem(this.storageKey) || '{}'); }
        _saveSessions(sessions) { localStorage.setItem(this.storageKey, JSON.stringify(sessions)); }
    }

    class ProfileStorage {
        constructor() { this.storageKey = CONFIG.STORAGE_KEYS.PROFILES; }
        _shouldPersist() { return !state.ephemeralMode; }
        async getPersonProfile(personId) { if (!this._shouldPersist()) return null; const p = JSON.parse(localStorage.getItem(this.storageKey) || '{}'); return p[personId] || null; }
        async savePersonProfile(personId, profile) { 
            if (!this._shouldPersist()) return;
            for (let i = 0; i < CONFIG.API_RETRY_COUNT; i++) {
                try {
                    const p = JSON.parse(localStorage.getItem(this.storageKey) || '{}'); 
                    p[personId] = profile; 
                    localStorage.setItem(this.storageKey, JSON.stringify(p));
                    return;
                } catch (e) {
                    if (i === CONFIG.API_RETRY_COUNT - 1) throw e;
                    await new Promise(res => setTimeout(res, 100 * Math.pow(2, i)));
                }
            }
        }
        async getAllProfiles() { if (!this._shouldPersist()) return {}; return JSON.parse(localStorage.getItem(this.storageKey) || '{}'); }
        async saveAllProfiles(profiles) { if (!this._shouldPersist()) return; localStorage.setItem(this.storageKey, JSON.stringify(profiles)); }
    }
    
    class GeminiApiClient {
        constructor(apiKey) { this.apiKey = apiKey; this.baseUrl = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent'; }
        async call(prompt, options = {}) {
            const payload = { contents: [{ parts: [{ text: prompt }] }], generationConfig: { temperature: options.temperature || 0.6, maxOutputTokens: 2048 } };
            if(options.responseSchema) { payload.generationConfig.responseMimeType = "application/json"; payload.generationConfig.responseSchema = options.responseSchema; }
            const responseText = await this._makeRequest(payload);
            try { return options.responseSchema ? JSON.parse(responseText) : { summary: responseText }; } catch (e) { console.error("API JSON Parse Error:", responseText); throw new Error("The AI returned an invalid response. Please try again."); }
        }
        async _makeRequest(payload) {
            if (!this.apiKey) throw new Error("API Key not set.");
            for (let attempt = 0; attempt < CONFIG.API_RETRY_COUNT; attempt++) {
                const controller = new AbortController(); const timeoutId = setTimeout(() => controller.abort(), CONFIG.API_TIMEOUT_MS);
                try {
                    const response = await fetch(this.baseUrl, { 
                        method: 'POST', 
                        headers: { 'X-Goog-Api-Key': this.apiKey, 'Content-Type': 'application/json' }, 
                        body: JSON.stringify(payload), 
                        signal: controller.signal 
                    });
                    clearTimeout(timeoutId);
                    if (!response.ok) { const errorData = await response.json().catch(() => ({})); throw new Error(`API Error ${response.status}: ${errorData.error?.message || response.statusText}`); }
                    const result = await response.json();
                    if (!result.candidates?.[0]?.content?.parts?.[0]?.text) throw new Error('Invalid API response structure received.');
                    return result.candidates[0].content.parts[0].text;
                } catch (error) { clearTimeout(timeoutId); if (attempt === CONFIG.API_RETRY_COUNT - 1 || error.name === 'AbortError') throw error; await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, attempt))); }
            }
            throw new Error("API request failed after multiple retries.");
        }
    }

    class ApiManager {
        constructor() {}
        getClient() { if (!state.settings.apiKey) throw new Error("API Key is not available. Please set it in Settings."); return new GeminiApiClient(state.settings.apiKey); }
        async call(prompt, options = {}) { return this.getClient().call(prompt, options); }
    }

    class PersonalizedWorkplaceAgent {
        constructor(apiManager, storage, sessionManager) { this.apiManager = apiManager; this.storage = storage; this.sessionManager = sessionManager; this.personProfiles = new Map(); }
        async analyze(message, userInput, personId, type, persona) {
            const personProfile = await this.getPersonProfile(personId);
            const session = this.sessionManager.getSession(personId);
            const prompt = this._buildAnalysisPrompt(message, userInput, personProfile, type, persona, session?.history);
            const result = await this.apiManager.call(prompt, { 
                responseSchema: { 
                    type: "OBJECT", 
                    properties: { 
                        "analysis": { 
                            type: "OBJECT", 
                            properties: { 
                                "insight": { "type": "STRING" }, 
                                "strategy": { "type": "STRING" }
                            } 
                        }, 
                        "responses": { 
                            type: "ARRAY", 
                            items: { 
                                type: "OBJECT", 
                                properties: { 
                                    "title": { "type": "STRING" }, 
                                    "text": { "type": "STRING" } 
                                }, 
                                required: ["title", "text"] 
                            } 
                        } 
                    } 
                } 
            });
            if (!validateAIResponse(result)) { throw new Error("AI returned an invalid response. Please try again."); }
            if (personId) {
                const fullUserMessage = [message, userInput].filter(Boolean).join('\n');
                const safeInsight = (result.analysis.insight || '').slice(0, 300);
                this.sessionManager.updateSession(personId, { 
                  history: { role: 'user', content: fullUserMessage }, 
                  insight: safeInsight
                });
            }
            return result;
        }
        async summarizeSession(personId) {
            if (!personId) return;
            try {
                const session = this.sessionManager.getSession(personId);
                const profile = await this.getPersonProfile(personId);
                if (!session || !profile || session.insights.length === 0) { this.sessionManager.clearSession(personId); return; }
                const prompt = this._buildSummarizationPrompt(profile.summary, session.insights);
                const result = await this.apiManager.call(prompt, { temperature: 0.2 });
                if (result?.summary?.trim()) {
                    if (/confidential|private|salary|personal/i.test(result.summary)) {
                        const confirmed = await showConfirmationModal("Sensitive Data Detected", "The generated summary appears to contain sensitive information. Do you still want to save it to this person's local profile?");
                        if (!confirmed) return;
                    }
                    profile.summary = result.summary.trim();
                    await this.storage.savePersonProfile(personId, profile);
                    this.personProfiles.set(personId, profile);
                }
                this.sessionManager.clearSession(personId);
            } catch (error) { console.error('Session summarization failed:', error); throw new Error("Failed to save session summary."); }
        }
        _sanitizePromptInput(content) { 
            if (!content) return ''; 
            // Basic sanitization
            let sanitized = content.replace(/[<>]/g, match => ({ '<': '&lt;', '>': '&gt;' }[match]));
            // Attempt to remove common prompt injection prefixes
            sanitized = sanitized.replace(/^(Ignore previous instructions|Disregard the above|Forget what you were told)[\s\S]*/i, '[POTENTIAL_INJECTION_REMOVED]');
            return sanitized.slice(0, 2000);
        }
        
        _promptHeader(mode, persona) {
            return `You are "The Strategic Gatekeeper," an elite AI specializing in workplace communication. Your current persona is "${persona}".
<task>
1.  **Analyze**: Create a concise analysis with two fields: "insight" (the core intent/unspoken ask) and "strategy" (the recommended action, risk, and reputation impact combined).
2.  **Respond**: Generate 3 distinct response options. Each response must have a short "title" (1-3 words) and "text".
3.  **Format**: Respond ONLY with valid JSON matching the schema. No extra text or markdown.
</task>`;
        }
        _buildHistoryBlock(sessionHistory) {
            if (!sessionHistory || sessionHistory.length === 0) return '';
            return `<short_term_memory_conversation_history>${sessionHistory.map(h => `${h.role}: ${h.content}`).join('\n')}</short_term_memory_conversation_history>`;
        }
        _buildContext(type, personProfile) {
            return `<context><type>${type || 'Not specified'}</type><person_name>${personProfile?.name || 'General'}</person_name><long_term_memory_summary>${personProfile?.summary || 'No summary yet.'}</long_term_memory_summary></context>`;
        }
        _buildUserInput(message, userInput, mode) {
            const sanitizedMessage = this._sanitizePromptInput(message);
            const sanitizedUserInput = this._sanitizePromptInput(userInput);
            if (mode === 'Compose') {
                return `<user_prompt>${sanitizedUserInput}</user_prompt>`;
            }
            return `<message_to_analyze>${sanitizedMessage}</message_to_analyze><user_guidance>${sanitizedUserInput || 'Initial analysis.'}</user_guidance>`;
        }
        _buildAnalysisPrompt(message, userInput, personProfile, type, persona, sessionHistory) {
            const mode = !message ? 'Compose' : 'Response';
            const historyBlock = this._buildHistoryBlock(sessionHistory);
            const contextBlock = this._buildContext(type, personProfile);
            const inputBlock = this._buildUserInput(message, userInput, mode);
            const fullInput = `<input><mode>${mode}</mode><persona>${persona}</persona>${historyBlock}${contextBlock}${inputBlock}</input>`;
            return `${this._promptHeader(mode, persona)}${fullInput}`;
        }
        _buildSummarizationPrompt(existingSummary, newInsights) { return `You are a profile synthesizer. Your task is to integrate new information from a recent conversation into an existing personality summary. Maintain a concise, third-person, analytical tone. Combine the existing summary with the new insights into a single, coherent, updated summary paragraph. <existing_summary>${existingSummary || 'This is the first observation for this person.'}</existing_summary> <new_insights_from_conversation>${newInsights.join(' ')}</new_insights_from_conversation> Respond with only the updated summary paragraph.`; }
        async getPersonProfile(personId) { 
            if (!personId) return null; 
            if (this.personProfiles.has(personId)) {
                const profile = this.personProfiles.get(personId);
                this.personProfiles.delete(personId);
                this.personProfiles.set(personId, profile);
                return profile;
            }
            
            if(this.personProfiles.size >= CONFIG.PROFILE_CACHE_MAX_SIZE) {
                const oldestKey = this.personProfiles.keys().next().value;
                this.personProfiles.delete(oldestKey);
            }
            
            const stored = await this.storage.getPersonProfile(personId); 
            if (stored) { this.personProfiles.set(personId, stored); return stored; } 
            return null; 
        }
    }

    const UIManager = {
        init() { this.updateUIState(); this.updateClipboardStatus(state.isClipboardMonitoringActive); this.setEmptyStateMessages(); },
        openModal(modalElement) {
            focusedElementBeforeModal = document.activeElement;
            modalElement.classList.remove('hidden');
            activeModal = modalElement;
            const firstFocusable = modalElement.querySelector('input, button, select, textarea');
            if (firstFocusable) firstFocusable.focus();
        },
        closeModal(modalElement) {
            modalElement.classList.add('hidden');
            if (activeModal === modalElement) activeModal = null;
            if (focusedElementBeforeModal) focusedElementBeforeModal.focus();
        },
        updateUIState(isLoading = false) {
            const loaderDisplay = isLoading ? 'flex' : 'none';
            dom.translationLoader.style.display = loaderDisplay;
            dom.outputLoader.style.display = loaderDisplay;

            const controlsToLock = [dom.messageInput, dom.userInput, dom.personaSelector, dom.clipboardToggle, dom.relationshipTypeSelector, dom.personSelector, dom.endConversationBtn, dom.clearInputsBtn];
            controlsToLock.forEach(c => c.disabled = isLoading);
            
            if (!isLoading) {
                 const isRoleSelected = !!state.selectedRelationshipType;
                dom.personSelector.disabled = !isRoleSelected;
                const isPersonSelected = !!state.selectedPersonId;
                dom.endConversationBtn.classList.toggle('hidden', !isPersonSelected);
            }
        },
        displayError(error) {
            const messageSpan = document.createElement('span');
            messageSpan.textContent = sanitizeText(error.message);
            dom.errorContainer.replaceChildren(messageSpan);
            if (error.message.includes('API Key')) {
                 const settingsBtn = document.createElement('button');
                 settingsBtn.textContent = 'Open Settings';
                 settingsBtn.onclick = () => dom.settingsBtn.click();
                 dom.errorContainer.appendChild(document.createTextNode(' ‚Üí '));
                 dom.errorContainer.appendChild(settingsBtn);
            }
            dom.errorContainer.classList.remove('hidden');
            console.error(error);
        },
        clearError() { dom.errorContainer.classList.add('hidden'); },
        showApiKeyCta() {
            dom.translationResult.classList.add('hidden');
            dom.apiKeyCta.classList.remove('hidden');
            dom.optionsContainer.replaceChildren();
            dom.analysisTitle.textContent = "AI Analysis";
        },
        hideApiKeyCta() {
            dom.translationResult.classList.remove('hidden');
            dom.apiKeyCta.classList.add('hidden');
            this.setEmptyStateMessages();
        },
        setEmptyStateMessages() {
            dom.translationResult.innerHTML = `<div class="empty-state-text">Analysis of your message will appear here.</div>`;
            dom.optionsContainer.innerHTML = `<div class="empty-state-text">AI-generated responses tailored to your chosen persona will appear here.</div>`;
        },
        displayAnalysis(analysis) {
            dom.translationResult.replaceChildren(); 
            if (!analysis) { 
                dom.translationResult.textContent = 'No analysis available.';
                return;
            }
            
            const insightP = document.createElement('p');
            const insightStrong = document.createElement('strong');
            insightStrong.textContent = "Insight: ";
            insightP.append(insightStrong, analysis.insight || 'N/A');

            const strategyP = document.createElement('p');
            const strategyStrong = document.createElement('strong');
            strategyStrong.textContent = "Strategy: ";
            strategyP.append(strategyStrong, analysis.strategy || 'N/A');

            dom.translationResult.append(insightP, strategyP);
        },
        displayResponses(responses) {
            dom.optionsContainer.replaceChildren();
            if (!Array.isArray(responses)) return;
            responses.forEach(response => {
                const card = document.createElement('div');
                card.className = 'response-card';
                const header = document.createElement('div');
                header.className = 'response-card-header';
                const title = document.createElement('h4');
                title.textContent = response.title;
                const copyBtn = document.createElement('button');
                copyBtn.className = 'copy-btn btn';
                copyBtn.textContent = 'Copy';
                copyBtn.dataset.text = response.text;
                header.append(title, copyBtn);
                const p = document.createElement('p');
                p.textContent = response.text;
                card.append(header, p);
                dom.optionsContainer.appendChild(card);
            });
        },
        updateClipboardStatus(isActive, message = null, type = null) {
            if (message) {
                dom.clipboardStatus.textContent = message;
                dom.clipboardStatus.className = type === 'danger' ? 'text-danger' : 'text-warning';
            } else {
                dom.clipboardStatus.textContent = isActive ? 'Monitoring' : 'Paused';
                dom.clipboardStatus.className = isActive ? 'text-success' : 'text-warning';
            }
        },
        updateAnalysisTitle(mode) {
            dom.analysisTitle.textContent = mode === 'compose' ? "AI Suggestions for Your Message" : "AI Analysis";
        },
        async populatePeopleSelector(profiles) {
            const type = state.selectedRelationshipType;
            if (!type) { dom.personSelectorContainer.classList.add('hidden'); return; }
            
            dom.personSelectorContainer.classList.remove('hidden');
            
            let peopleInType;
            if (type === 'Other') {
                peopleInType = Object.values(profiles).filter(p => !CONFIG.STANDARD_RELATIONSHIPS.includes(p.type));
            } else {
                peopleInType = Object.values(profiles).filter(p => p.type === type);
            }

            dom.personSelector.innerHTML = `<option value="">-- General ${type} --</option>`;
            peopleInType.forEach(p => dom.personSelector.add(new Option(p.name, p.id)));
            dom.personSelector.add(new Option('-- Add New Person --', 'add_new_person'));
            dom.personSelector.value = state.selectedPersonId || "";
        },
        async renderPeopleList(profiles) {
            dom.peopleList.replaceChildren();
            Object.values(profiles).forEach(p => { 
                const div = document.createElement('div');
                div.className = 'person-item';
                
                const header = document.createElement('div');
                header.className = "person-item-header";

                const nameSpan = document.createElement('span');
                nameSpan.textContent = `${p.name} (${p.type})`;
                
                const controlsDiv = document.createElement('div');
                controlsDiv.className = "person-controls";

                const profileBtn = document.createElement('button');
                profileBtn.className = "btn view-profile-btn";
                profileBtn.dataset.id = p.id;
                profileBtn.textContent = "Profile";

                const delBtn = document.createElement('button');
                delBtn.className = "btn btn-danger";
                delBtn.dataset.id = p.id;
                delBtn.textContent = "Delete";

                controlsDiv.append(profileBtn, delBtn);
                header.append(nameSpan, controlsDiv);
                div.append(header);
                dom.peopleList.appendChild(div); 
            });
        },
        toggleProfileAccordion(personItem, personProfile) {
            const existingDetails = personItem.querySelector('.profile-details');
            if (existingDetails) { existingDetails.remove(); return; }
            
            const detailsDiv = document.createElement('div');
            detailsDiv.className = 'profile-details';

            const h4 = document.createElement('h4');
            h4.textContent = "AI Summary";
            detailsDiv.appendChild(h4);

            if (personProfile.summary && personProfile.summary.length > CONFIG.PROFILE_SUMMARY_WARNING_LENGTH) {
                const warnP = document.createElement('p');
                warnP.className = "summary-warning";
                warnP.textContent = "Note: This summary is becoming long. Consider editing for clarity and efficiency.";
                detailsDiv.appendChild(warnP);
            }

            const summaryText = personProfile.summary || '';
            const textarea = document.createElement('textarea');
            textarea.id = `summary-${personProfile.id}`;
            textarea.className = 'input-field';
            textarea.rows = 6;
            textarea.value = summaryText;

            const charCountP = document.createElement('p');
            charCountP.className = 'summary-char-count';
            charCountP.id = `count-${personProfile.id}`;
            charCountP.textContent = `${summaryText.length} / ${CONFIG.PROFILE_SUMMARY_WARNING_LENGTH}`;

            textarea.addEventListener('input', () => { 
                charCountP.textContent = `${textarea.value.length} / ${CONFIG.PROFILE_SUMMARY_WARNING_LENGTH}`; 
            });

            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'modal-actions';
            actionsDiv.style.marginTop = '0.5rem';

            const saveBtn = document.createElement('button');
            saveBtn.className = "btn btn-primary save-profile-btn";
            saveBtn.dataset.id = personProfile.id;
            saveBtn.textContent = "Save Profile";

            actionsDiv.appendChild(saveBtn);
            detailsDiv.append(textarea, charCountP, actionsDiv);
            personItem.appendChild(detailsDiv);
        },
        updateContextualControls(personId) { dom.endConversationBtn.classList.toggle('hidden', !personId); },
        updateEphemeralBadge() { dom.ephemeralBadge.classList.toggle('hidden', !state.ephemeralMode); }
    };
    
    const storage = new ProfileStorage();
    const sessionManager = new SessionManager();
    const apiManager = new ApiManager();
    const agent = new PersonalizedWorkplaceAgent(apiManager, storage, sessionManager);

    async function handleAnalysisRequest() {
        if (!state.settings.apiKey) {
            UIManager.showApiKeyCta();
            return;
        }
        
        const mode = !state.detectedMessage.trim() ? 'compose' : 'analyze';
        UIManager.updateAnalysisTitle(mode);

        if (!state.detectedMessage.trim() && !dom.userInput.value.trim()) {
            return; // Do nothing if no text is present
        }
        UIManager.updateUIState(true); UIManager.clearError();
        dom.translationResult.textContent = 'Analyzing...'; dom.optionsContainer.replaceChildren();
        try { const result = await agent.analyze(state.detectedMessage, dom.userInput.value, state.selectedPersonId, state.selectedRelationshipType, state.selectedPersona); UIManager.displayAnalysis(result.analysis); UIManager.displayResponses(result.responses); } catch (error) { UIManager.displayError(error); dom.translationResult.textContent = `An error occurred.`; } finally { UIManager.updateUIState(false); }
    }
    
    function migrateStorage() {
        for (const keyType in CONFIG.OLD_STORAGE_KEYS) {
            const newKey = CONFIG.STORAGE_KEYS[keyType];
            const oldKeys = CONFIG.OLD_STORAGE_KEYS[keyType];
            
            for (const oldKey of oldKeys) {
                const oldData = localStorage.getItem(oldKey);
                if (oldData) {
                    if (!localStorage.getItem(newKey)) {
                        localStorage.setItem(newKey, oldData);
                    }
                    localStorage.removeItem(oldKey);
                }
            }
        }
    }

    function loadSettings() { 
        migrateStorage();
        const saved = JSON.parse(localStorage.getItem(CONFIG.STORAGE_KEYS.SETTINGS) || '{}');
        state.settings.onboardingDismissed = saved.onboardingDismissed || false; 
        state.ephemeralMode = saved.ephemeralMode || false; 
        state.settings.apiKey = saved.apiKey || null;
        UIManager.updateEphemeralBadge(); 
    }
    async function saveSettings() {
        const apiKey = dom.geminiApiKeyInput.value;
        state.settings.apiKey = apiKey;
        state.ephemeralMode = dom.ephemeralToggle.checked;
        UIManager.updateEphemeralBadge();
        
        const settingsToSave = { 
            onboardingDismissed: true, 
            ephemeralMode: state.ephemeralMode, 
            apiKey: state.settings.apiKey 
        };

        if (!state.ephemeralMode) { 
            localStorage.setItem(CONFIG.STORAGE_KEYS.SETTINGS, JSON.stringify(settingsToSave)); 
        }
        UIManager.closeModal(dom.settingsModal);
        
        const wasApiKeyMissing = !state.settings.apiKey;

        if (state.settings.apiKey) {
            UIManager.hideApiKeyCta();
            if (wasApiKeyMissing) {
                dom.translationResult.innerHTML = `<div class="empty-state-text"><strong>Welcome!</strong> Your API key is set. <br>1. Paste a message. <br>2. Set the context. <br>3. Get AI-powered responses.</div>`;
            }
        } else {
            UIManager.showApiKeyCta();
        }
        UIManager.updateUIState();
    }
    function renderSettings() { 
        dom.geminiApiKeyInput.value = state.settings.apiKey || ''; 
        dom.ephemeralToggle.checked = state.ephemeralMode; 
    }
    function isInsideSidebar() { return window.innerWidth <= CONFIG.SIDEBAR_MAX_WIDTH; }

    async function initializeApp() {
        UIManager.init();
        await UIManager.populatePeopleSelector(await storage.getAllProfiles());
        const debouncedAnalysis = debounce(handleAnalysisRequest, CONFIG.DEBOUNCE_MS);
        
        dom.messageInput.addEventListener('input', () => { state.detectedMessage = dom.messageInput.value; debouncedAnalysis(); });
        dom.userInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && e.ctrlKey) { e.preventDefault(); handleAnalysisRequest(); } else { debouncedAnalysis(); } });
        dom.clipboardToggle.addEventListener('change', async (e) => {
            state.isClipboardMonitoringActive = e.target.checked; 
            if (state.isClipboardMonitoringActive) {
                try {
                    const permission = await navigator.permissions.query({ name: "clipboard-read" });
                     if (permission.state === 'denied') {
                        state.isClipboardMonitoringActive = false;
                        e.target.checked = false;
                        UIManager.updateClipboardStatus(false, 'Permission Denied', 'danger');
                        return;
                    }
                } catch(err) {
                   console.warn("Clipboard permissions query not supported; proceeding optimistically.");
                }
            }
            UIManager.updateClipboardStatus(state.isClipboardMonitoringActive);
        });
        dom.personaSelector.addEventListener('change', (e) => { state.selectedPersona = e.target.value; handleAnalysisRequest(); });
        
        const handlePersonChange = async (oldPersonId) => {
            try { 
                if (oldPersonId) {
                    UIManager.updateUIState(true);
                    await agent.summarizeSession(oldPersonId); 
                }
            } catch (error) { 
                console.warn('Failed to summarize session on person change:', error);
                UIManager.displayError(new Error('Failed to save session summary.'));
            } finally {
                UIManager.updateUIState(false);
            }
            state.selectedPersonId = dom.personSelector.value || null;
            UIManager.updateUIState();
            handleAnalysisRequest();
        };

        dom.relationshipTypeSelector.addEventListener('change', async (e) => { 
            UIManager.updateUIState(true);
            try {
                await agent.summarizeSession(state.selectedPersonId); 
            } catch(error) {
                console.error("Summarization failed during relationship change:", error);
                UIManager.displayError(new Error("Failed to save previous session."));
            }
            state.selectedRelationshipType = e.target.value; 
            state.selectedPersonId = null; 
            await UIManager.populatePeopleSelector(await storage.getAllProfiles()); 
            UIManager.updateUIState(false); 
        });
        
        dom.personSelector.addEventListener('change', async () => {
            if (dom.personSelector.value === 'add_new_person') {
                dom.customRoleGroup.classList.toggle('hidden', state.selectedRelationshipType !== 'Other');
                await UIManager.renderPeopleList(await storage.getAllProfiles());
                UIManager.openModal(dom.peopleModal);
                dom.personSelector.value = state.selectedPersonId || "";
            } else { handlePersonChange(state.selectedPersonId); }
        });

        dom.clearInputsBtn.addEventListener('click', () => { 
            state.detectedMessage = ''; 
            dom.messageInput.value = ''; 
            dom.userInput.value = ''; 
            if(state.settings.apiKey) UIManager.hideApiKeyCta();
            else UIManager.showApiKeyCta();
            dom.optionsContainer.replaceChildren(); 
            UIManager.clearError(); 
        });
        dom.endConversationBtn.addEventListener('click', async () => { UIManager.updateUIState(true); await agent.summarizeSession(state.selectedPersonId); UIManager.updateUIState(false); });

        dom.settingsBtn.addEventListener('click', () => { renderSettings(); UIManager.openModal(dom.settingsModal); });
        dom.ctaSettingsBtn.addEventListener('click', () => dom.settingsBtn.click());
        dom.cancelSettingsBtn.addEventListener('click', () => UIManager.closeModal(dom.settingsModal));
        dom.saveSettingsBtn.addEventListener('click', saveSettings);
        dom.clearDataBtn.addEventListener('click', async () => {
            if(await showConfirmationModal('Clear Data', 'Are you sure you want to delete ALL local data? This is irreversible.')) {
                Object.values(CONFIG.STORAGE_KEYS).forEach(key => localStorage.removeItem(key));
                window.location.reload();
            }
        });
        
        dom.globalManagePeopleBtn.addEventListener('click', async () => {
            dom.customRoleGroup.classList.toggle('hidden', state.selectedRelationshipType !== 'Other');
            await UIManager.renderPeopleList(await storage.getAllProfiles()); 
            UIManager.openModal(dom.peopleModal); 
        });
        dom.closePeopleBtn.addEventListener('click', () => UIManager.closeModal(dom.peopleModal));
        dom.addPersonBtn.addEventListener('click', async () => {
            const formGroup = dom.addPersonBtn.closest('.form-group');
            const existingError = formGroup.querySelector('.error-message');
            if (existingError) existingError.remove();
            
            const name = dom.newPersonName.value.trim();
            let role = state.selectedRelationshipType;

            if (role === 'Other') {
                role = dom.newPersonRole.value.trim();
                if (!role) {
                    const errorSpan = document.createElement('div');
                    errorSpan.textContent = "Please specify a custom relationship.";
                    errorSpan.className = 'error-message';
                    dom.customRoleGroup.appendChild(errorSpan);
                    return;
                }
            }

            if (!name) {
                const errorSpan = document.createElement('div');
                errorSpan.textContent = "A name must be entered.";
                errorSpan.className = 'error-message';
                dom.newPersonName.insertAdjacentElement('afterend', errorSpan);
                return;
            }

            const id = `person_${Date.now()}`; 
            const newProfile = { id, name, type: role, summary: `Profile created for ${name}.` };
            
            await storage.savePersonProfile(id, newProfile);
            dom.newPersonName.value = '';
            dom.newPersonRole.value = '';
            
            const allProfiles = await storage.getAllProfiles();
            await UIManager.renderPeopleList(allProfiles);
            await UIManager.populatePeopleSelector(allProfiles);
        });
        dom.peopleList.addEventListener('click', async (e) => {
            const button = e.target.closest('button'); if (!button) return;
            const personId = button.dataset.id; const personItem = button.closest('.person-item');
            if (button.classList.contains('view-profile-btn')) { const profile = await storage.getPersonProfile(personId); if(profile) UIManager.toggleProfileAccordion(personItem, profile); } 
            else if (button.classList.contains('btn-danger')) { 
                if (await showConfirmationModal("Delete Person", "Are you sure you want to delete this person and all their data? This cannot be undone.")) { 
                    const profiles = await storage.getAllProfiles(); 
                    delete profiles[personId]; 
                    await storage.saveAllProfiles(profiles); 
                    if (state.selectedPersonId === personId) state.selectedPersonId = null;
                    await UIManager.renderPeopleList(profiles); 
                    await UIManager.populatePeopleSelector(profiles); 
                } 
            }
            else if (button.classList.contains('save-profile-btn')) {
                const summaryTextarea = personItem.querySelector(`#summary-${personId}`);
                const profile = await storage.getPersonProfile(personId); if (!profile) return;
                profile.summary = summaryTextarea.value; 
                await storage.savePersonProfile(personId, profile);
                await UIManager.populatePeopleSelector(await storage.getAllProfiles());
                button.textContent = 'Saved!'; 
                setTimeout(() => { button.textContent = 'Save Profile'; }, 2000);
            }
        });

        document.body.addEventListener('click', (e) => { const button = e.target.closest('.copy-btn'); if (button) { navigator.clipboard.writeText(button.dataset.text).then(() => { button.textContent = 'Copied!'; setTimeout(() => button.textContent = 'Copy', 2000); }).catch(err => { console.error("Failed to copy text:", err); }); } });
        
        setInterval(() => { if (state.isClipboardMonitoringActive && document.hasFocus()) { navigator.clipboard.readText().then(text => { if (text && text.trim() && text !== state.lastClipboardContent) { state.lastClipboardContent = text; state.detectedMessage = text; dom.messageInput.value = text; debouncedAnalysis(); } }).catch(err => { state.isClipboardMonitoringActive = false; dom.clipboardToggle.checked = false; UIManager.updateClipboardStatus(false, 'Permission Denied', 'danger'); console.warn("Clipboard read permission may have been denied."); }); } }, CONFIG.CLIPBOARD_POLL_MS);
    
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && activeModal) UIManager.closeModal(activeModal);
            if (e.key === 'Tab' && activeModal) {
                const focusableElements = activeModal.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
                const firstElement = focusableElements[0];
                const lastElement = focusableElements[focusableElements.length - 1];
                if (e.shiftKey) {
                    if (document.activeElement === firstElement) { lastElement.focus(); e.preventDefault(); }
                } else {
                    if (document.activeElement === lastElement) { firstElement.focus(); e.preventDefault(); }
                }
            }
        });
        UIManager.updateUIState();
    }
    
    async function main() {
        loadSettings();
        if (!isInsideSidebar() && !state.settings.onboardingDismissed) {
            dom.onboardingOverlay.classList.remove('hidden');
            dom.dismissOnboardingBtn.addEventListener('click', () => {
                state.settings.onboardingDismissed = true;
                if(!state.ephemeralMode) localStorage.setItem(CONFIG.STORAGE_KEYS.SETTINGS, JSON.stringify(state.settings));
                dom.onboardingOverlay.classList.add('hidden');
                dom.app.classList.remove('hidden');
                initializeApp().then(() => {
                    if (!state.settings.apiKey) UIManager.showApiKeyCta();
                }).catch(console.error);
            }, { once: true });
        } else {
            dom.app.classList.remove('hidden');
            await initializeApp();
            if (!state.settings.apiKey) UIManager.showApiKeyCta();
        }
    }
    
    main().catch(console.error);
    </script>
</body>
</html>

